{"/home/travis/build/npmtest/node-npmtest-node-hue-api/test.js":"/* istanbul instrument in package npmtest_node_hue_api */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-hue-api/lib.npmtest_node_hue_api.js":"/* istanbul instrument in package npmtest_node_hue_api */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_hue_api = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_hue_api = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-hue-api/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-hue-api && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_hue_api */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_hue_api\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_hue_api.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_node_hue_api.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_hue_api.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_node_hue_api.__dirname + '/lib.npmtest_node_hue_api.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/index.js":"\"use strict\";\n\n//\n// This wrapper is to provide some continuity in the modifications of the APIs over time\n//\n\nvar bridgeDiscovery = require(\"./hue-api/bridge-discovery\")\n    , Hue = require(\"./hue-api\")\n    , lightState = require(\"./hue-api/lightstate\")\n    , scheduledEvent = require(\"./hue-api/scheduledEvent\")\n    , scene = require(\"./hue-api/scene\")\n    , timer = require(\"./hue-api/timer\")\n    , ApiError = require(\"./hue-api/errors\").ApiError\n    ;\n\n\nfunction deprecated(fn, message) {\n    return function () {\n        var args = Array.prototype.slice.call(arguments);\n        console.error(message);\n        return fn.apply(this, args);\n    };\n}\n\n\nmodule.exports = {\n    HueApi: Hue,\n    BridgeApi: Hue,\n    api: Hue,\n\n    //TODO document this, it is currently broken though\n    connect: function(config) {\n        return new Hue(config);\n    },\n\n    lightState: lightState,\n    scheduledEvent: scheduledEvent,\n    scene: scene,\n    timer: timer,\n\n    upnpSearch: bridgeDiscovery.networkSearch,\n    nupnpSearch: bridgeDiscovery.locateBridges,\n\n    locateBridges: deprecated(bridgeDiscovery.locateBridges\n        , \"'locateBridges' is deprecated, please use 'nupnpSearch' instead\"),\n\n    searchForBridges: deprecated(\n        bridgeDiscovery.networkSearch\n        , \"'searchForBridges' is deprecated, please use 'upnpSearch' instead\"\n    ),\n\n    ApiError: ApiError\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/bridge-discovery.js":"\"use strict\";\n\nvar url = require(\"url\")\n    , Q = require(\"q\")\n    , search = require(\"./search\")\n    , http = require(\"./httpPromise\")\n    , utils = require(\"./utils\")\n    , discovery = require(\"./commands/discovery\")\n    ;\n\n/**\n * Will locate the Philips Hue Devices on the network. Depending upon the speed and size of the network the timeout\n * may need to be adjusted to locate the Hue Bridge.\n *\n * @param timeout The maximum time to wait for Hue Devices to be located. If not specified will use the default of 5\n * seconds.\n * @return A promise that will resolve the Hue Bridges as an Array of {\"id\": {String}, \"ipaddress\": {String}} objects.\n */\nmodule.exports.networkSearch = function (timeout) {\n    return search.locateBridges(timeout).then(_identifyBridges);\n};\n\n/**\n * Uses the http://www.meethue.com/api/nupnp call to search for any bridges locally on the network. This lookup can be\n * significantly faster than issuing search requests in the {locateBridges} function.\n *\n * @param cb An option callback function that will be informed of results.\n * @returns {Q.promise} A promise that will resolve the addresses of the bridges, or {null} if a callback was provided.\n */\nmodule.exports.locateBridges = function (cb) {\n    var promise = http.invoke(discovery.upnpLookup, {host: \"www.meethue.com\", ssl: true});\n    return utils.promiseOrCallback(promise, cb);\n};\n\n/**\n * Obtains an object representation of the Description XML.\n *\n * @param host The host to get the description XML from.\n * @return {*} The object representing some of the values in the description XML.\n * @private\n */\nmodule.exports.description = function (host) {\n    return http.invoke(discovery.description, {\"host\": host})\n        .then(_parseDescription);\n};\n\n/**\n * Identifies the bridges based on the response from possible devices from SSDP search\n * @param possibleBridges The results from the search to be processed.\n * @return A promise that will process all the results and return only the valid Hue Bridges.\n * @private\n */\nfunction _identifyBridges(possibleBridges) {\n    var lookups = []\n        , path\n        //, uri\n        ;\n\n    for (path in possibleBridges) {\n        if (possibleBridges.hasOwnProperty(path)) {\n            //uri = parseUri(path);\n            lookups.push(followLocationResponse(path).then(_getHueBridgeHost));\n        }\n    }\n    return Q.all(lookups);\n}\n\n/**\n * Performs a GET on the provided path, the location response from the bridge.\n * This function expects there to be an XML description document present at the provided path.\n * @param path The path in the LOCATION response from SSDP lookup.\n */\nfunction followLocationResponse(path) {\n    return http.simpleGet(path)\n        .then(_parseDescription)\n        .fail(function (err) {\n            // Do nothing with services that do not respond with an XML document\n        })\n        ;\n}\n\n/**\n * Parses the XML Description and converts it into an Object.\n * @param xml The XML to parse and convert into an object\n * @return {Function|promise|promise|exports.promise}\n * @private\n */\nfunction _parseDescription(xml) {\n    var xml2js = require(\"xml2js\")\n        , parser = new xml2js.Parser()\n        , deferred = Q.defer()\n        ;\n\n    parser.parseString(xml, function (err, data) {\n        var result = null\n            , icons\n            ;\n\n        if (err) {\n            deferred.reject(err);\n        } else {\n            result = {\n                \"version\": {\n                    \"major\": data.root.specVersion[0].major[0],\n                    \"minor\": data.root.specVersion[0].minor[0]\n                },\n                \"url\": data.root.URLBase[0],\n                \"name\": data.root.device[0].friendlyName[0],\n                \"manufacturer\": data.root.device[0].manufacturer[0],\n                \"model\": {\n                    \"name\": data.root.device[0].modelName[0],\n                    \"description\": data.root.device[0].modelDescription[0],\n                    \"number\": data.root.device[0].modelNumber[0],\n                    \"serial\": data.root.device[0].serialNumber[0],\n                    \"udn\": data.root.device[0].UDN[0]\n                }\n            };\n\n            if (data.root.device[0].iconList\n                && data.root.device[0].iconList[0]\n                && data.root.device[0].iconList[0].icon) {\n                icons = [];\n\n                data.root.device[0].iconList[0].icon.forEach(function (icon) {\n                    icons.push({\n                        mimetype: icon.mimetype[0],\n                        height: icon.height[0],\n                        width: icon.width[0],\n                        depth: icon.depth[0],\n                        url: icon.url[0]\n                    });\n                });\n\n                result.icons = icons;\n            }\n\n            deferred.resolve(result);\n        }\n    });\n\n    return deferred.promise;\n}\n\nfunction _isHueBridge(description) {\n    var name;\n\n    if (description && description.model && description.model.name) {\n        name = description.model.name;\n        if (name.toLowerCase().indexOf(\"philips hue bridge\") >= 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _getHueBridgeHost(description) {\n    var uri;\n\n    if (_isHueBridge(description)) {\n        uri = url.parse(description.url);\n        return {\n            \"id\": description.model.serial,\n            \"ipaddress\": uri.hostname\n        };\n    }\n    return null;\n}","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/search.js":"\"use strict\";\n\nvar Q = require(\"q\"),\n    dgram = require('dgram'),\n    EventEmitter = require('events').EventEmitter,\n    util = require(\"util\");\n\nvar socketCleanUp = new SocketCleanUp();\n\n/**\n * Locates possible Philips Hue Bridges on the network.\n * @param timeout The maximum time to wait for responses, or if none provided will default to 5 seconds\n * @return {Function|promise|promise|exports.promise}\n */\nfunction locateBridges(timeout) {\n    var deferred = Q.defer(),\n        search = new SSDPSearch(timeout),\n        results = [];\n\n    search.on(\"response\", function(value) {\n        results.push(value);\n    });\n    search.search();\n\n    // Give up after the timeout and process whatever results we have\n    setTimeout(function() {\n        _close(search);\n        deferred.resolve(_filterResults(results));\n    }, timeout || 5000);\n\n    return deferred.promise;\n}\nmodule.exports.locateBridges = locateBridges;\n\nfunction SSDPSearch(timeout) {\n    var self = this;\n\n    self.socket = dgram.createSocket('udp4');\n\n    self.socket.on('error', function (err) {\n        console.log('############### Got an error!');\n        console.trace(err);\n    });\n\n    self.socket.on('message', function onMessage(msg, rinfo) {\n        var msgStrings = msg.toString().split(\"\\r\\n\");\n\n        // HTTP/#.# ### Response\n        if (msgStrings[0].match(/HTTP\\/(\\d{1})\\.(\\d{1}) (\\d+) (.*)/)) {\n            self.emit('response', _parseSearchResponse(msgStrings.slice(1)));\n        }\n    });\n\n    socketCleanUp.add(self);\n    socketCleanUp.registerExitListener();\n}\nSSDPSearch.prototype.__proto__ = EventEmitter.prototype;\n\nSSDPSearch.prototype.search = function search() {\n    var ip = \"239.255.255.250\",\n        port = 1900;\n\n    var pkt = new Buffer(_buildSearchPacket(\n        {\n            \"HOST\": ip + \":\" + port,\n            \"MAN\": \"ssdp:discover\",\n            \"MX\": 10,\n//            \"ST\": \"SsdpSearch:all\"\n            \"ST\": \"urn:schemas-upnp-org:device:Basic:1\"\n        }\n    ));\n    this.socket.send(pkt, 0, pkt.length, port, ip);\n};\n\nfunction _close(target) {\n    if (!target.closed) {\n        target.closed = true;\n        target.socket.close();\n    }\n    socketCleanUp.remove(target);\n}\n\nfunction _buildSearchPacket(vars) {\n    var packet = \"M-SEARCH * HTTP/1.1\\r\\n\";\n    Object.keys(vars).forEach(function (n) {\n        packet += n + \": \" + vars[n] + \"\\r\\n\";\n    });\n    return packet + \"\\r\\n\";\n}\n\nfunction _parseSearchResponse(lines) {\n    var line,\n        separatorIndex,\n        key,\n        value,\n        result = {},\n        idx,\n        len;\n\n    for (idx = 0, len = lines.length; idx < lines.length; idx++) {\n        line = lines[idx];\n        separatorIndex = line.indexOf(\":\");\n        if (separatorIndex > 0 && separatorIndex < line.length) {\n            key = line.substring(0, separatorIndex).toLowerCase();\n            value = line.substring(separatorIndex + 1, line.length).trim();\n            result[key] = value;\n        }\n    }\n    return result;\n}\n\nfunction _filterResults(resultObjects) {\n    var uniqueValues = {};\n\n    resultObjects.forEach(function(result) {\n        if (! uniqueValues[result.location]) {\n            uniqueValues[result.location] = result;\n        } else {\n            uniqueValues[result.location] = _combineResults(uniqueValues[result.location], result);\n        }\n    });\n    return uniqueValues;\n}\n\nfunction _combineResults(objectOne, objectTwo) {\n    var result = {},\n        key,\n        array;\n\n    for (key in objectOne) {\n        result[key] = objectOne[key];\n    }\n\n    for (key in objectTwo) {\n        if (result[key] !== objectTwo[key]) {\n            if (util.isArray(result[key])) {\n                _addUnique(result[key], objectTwo[key]);\n            } else {\n                array = [];\n                array.push(result[key]);\n                array.push(objectTwo[key]);\n                result[key] = array;\n            }\n        }\n    }\n    return result;\n}\n\nfunction _addUnique(array, value) {\n    var found = false,\n        idx,\n        len;\n\n    for (idx = 0, len = array.length; idx < len; idx++) {\n        found = array[idx] === value;\n        if (found) {\n            break;\n        }\n    }\n\n    if (!found) {\n        array.push(value);\n    }\n}\n\n/**\n * A socket register to take care of closing all sockets that are opened, if not already closed\n *\n * @constructor\n */\nfunction SocketCleanUp() {\n    this._searches = [];\n    this._registered = false;\n}\n\nSocketCleanUp.prototype.add = function(search) {\n    this._searches.push(search);\n};\n\nSocketCleanUp.prototype.remove = function(search) {\n    var self = this\n        , searches = self._searches\n        , idx = searches.indexOf(search)\n        ;\n\n    if (idx > -1) {\n        searches.splice(idx, 1)\n    }\n};\n\nSocketCleanUp.prototype.finished = function() {\n    var self = this\n        , searches = self._searches\n        ;\n\n    searches.forEach(function(search) {\n        _close(search);\n    });\n};\n\nSocketCleanUp.prototype.registerExitListener = function() {\n    var self = this;\n\n    if (! self._registered) {\n        process.on(\"exit\", self.finished.bind(self));\n        self._registered = true;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/httpPromise.js":"'use strict';\n\nvar url = require(\"url\")\n  , util = require(\"util\")\n  , Q = require(\"q\")\n  , axios = require(\"axios\")\n  , httpAdapter = require(\"axios/lib/adapters/http\")\n  , errors = require(\"./errors.js\")\n  , debug = /hue-api/.test(process.env.NODE_DEBUG)\n  ;\n\nvar defaultOptions = {\n  adapter: httpAdapter,\n};\n\nfunction buildOptions(command, parameters) {\n  var options = {\n      adapter: httpAdapter,\n      debug: debug,\n      headers: {}\n    },\n    body,\n    urlObj = {\n      protocol: parameters.ssl ? \"https\" : \"http\",\n      hostname: parameters.host\n    };\n\n  if (parameters.port) {\n    urlObj.port = parameters.port;\n  }\n\n  options.timeout = parameters.timeout || 10000;\n  options.method = command.method || \"GET\";\n\n  if (command.getPath) {\n    urlObj.pathname = command.getPath(parameters);\n  } else {\n    throw new errors.ApiError(\"Cannot get the path to invoke from the command\");\n  }\n  options.url = url.format(urlObj);\n\n  // Check if the command has body arguments and process them accordingly\n  if (command.bodyArguments && command.buildRequestBody) {\n    body = command.buildRequestBody(parameters.values);\n\n    if (command.bodyType === \"application/json\") {\n      options.responseType = \"json\";\n      options.data = JSON.stringify(body);\n    } else {\n      throw new errors.ApiError(\"No support for \" + command.bodyType + \" in requests.\");\n    }\n  }\n\n  if (command.response) {\n    options.headers.Accept = command.response;\n  }\n\n  return options;\n}\n\nfunction getError(jsonObject) {\n  var result = null\n    , idx = 0\n    , len = 0\n    ;\n\n  if (jsonObject) {\n    if (util.isArray(jsonObject)) {\n      for (idx = 0, len = jsonObject.length; idx < len; idx++) {\n        result = getError(jsonObject[idx]);\n        // Stop on the first error\n        if (result) {\n          break;\n        }\n      }\n    } else if (jsonObject.error) {\n      return {\n        type: jsonObject.error.type,\n        description: jsonObject.error.description,\n        address: jsonObject.error.address\n      };\n    }\n  }\n  return result;\n}\n\nfunction checkForError(result) {\n  var jsonResult\n    , jsonError\n    ;\n\n  jsonResult = result.data;\n  jsonError = getError(jsonResult);\n\n  if (jsonError) {\n    throw new errors.ApiError(jsonError);\n  }\n  return jsonResult;\n}\n\nfunction requireStatusCode200(result) {\n  if (result.status !== 200) {\n    throw new errors.ApiError(\n      {\n        type: \"Response Error\",\n        description: \"Unexpected response status; \" + result.statusCode,\n        statusCode: result.statusCode\n      }\n    );\n  }\n  return result;\n}\n\nfunction generateErrorsIfMatched(map) {\n  return function (result) {\n    if (map && map[result.statusCode]) {\n      throw new errors.ApiError({\n        type: result.statusCode,\n        message: map[result.statusCode]\n      });\n    }\n    return result;\n  };\n}\n\nmodule.exports.invoke = function (command, parameters) {\n  var options = buildOptions(command, parameters)\n    , promise\n    ;\n\n  //promise = requestUtil.request(options);\n  promise = wrapAxios(axios(options));\n\n  if (command.statusCodeMap) {\n    promise = promise.then(generateErrorsIfMatched(command.statusCodeMap));\n  }\n\n  promise = promise\n    .then(requireStatusCode200)\n    .then(function (requestResult) {\n      var result;\n\n      if (options.headers.Accept === \"application/json\") {\n        result = checkForError(requestResult);\n      } else {\n        result = requestResult.data;\n      }\n      return result;\n    });\n\n  if (command.postProcessing) {\n    command.postProcessing.forEach(function (fn) {\n      promise = promise.then(fn);\n    });\n  }\n\n  return promise;\n};\n\nmodule.exports.simpleGet = function (uri) {\n  return wrapAxios(axios.get(uri, defaultOptions))\n      .then(requireStatusCode200)\n      .then(function(result) {\n          return result.data;\n      });\n};\n\n/**\n * Wrap an axios ES6 promise inside a Q promise.\n * @param promise The axios promise to wrap\n * @returns {*|promise}\n */\nfunction wrapAxios(promise) {\n  var deferred = Q.defer();\n\n  promise.then(function (result) {\n      deferred.resolve(result);\n    })\n    .catch(function (err) {\n      deferred.reject(err);\n    });\n\n  return deferred.promise;\n}","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/errors.js":"\"use strict\";\n\nvar util = require('util');\n\n/**\n * An Abstract base class for custom errors.\n * @param msg The error message\n * @param constr The constructor to call.\n * @constructor\n */\nvar AbstractError = function (msg, constr) {\n    // If defined, pass the constr property to V8's captureStackTrace to clean up the output\n    Error.captureStackTrace(this, constr || this);\n\n    // If defined, store a custom error message\n    this.message = msg || \"Error\";\n};\nutil.inherits(AbstractError, Error);\nAbstractError.prototype.name = \"Abstract Error\";\n\n/**\n * An Error Type for API related errors when calling the Philips Hue API.\n * @param error The error object returned from the request.\n * @constructor\n */\nvar ApiError = function (error) {\n    var errorMessage,\n        type;\n\n    if (typeof(error) === 'string') {\n        errorMessage = error;\n        type = 0;\n    } else {\n        errorMessage = error.message || error.description;\n        type = error.type;\n    }\n\n    ApiError.super_.call(this, errorMessage, this.constructor);\n    this.type = type;\n\n    if (error.address) {\n        this.address = error.address;\n    }\n};\nutil.inherits(ApiError, AbstractError);\nApiError.prototype.name = \"Api Error\";\n\nmodule.exports.ApiError = ApiError;","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/utils.js":"\"use strict\";\n\nvar util = require(\"util\");\n\n/**\n * Checks the callback and if it is valid, will resolve the promise an utilize the callback to inform of results,\n * otherwise the promise is returned to the caller to chain.\n *\n * @param promise The promise being invoked\n * @param cb The callback function, which is optional\n * @returns {*} The promise if there is not a valid callback, or null, if the callback is used to resolve the promise.\n */\nmodule.exports.promiseOrCallback = function (promise, cb) {\n    var promiseResult = promise;\n\n    if (cb && typeof cb === \"function\") {\n        module.exports.resolvePromise(promise, cb);\n        // Do not return the promise, as the callbacks will have forced it to resolve\n        promiseResult = null;\n    }\n\n    return promiseResult;\n};\n\n/**\n * Terminates a promise chain and invokes a callback with the results.\n *\n * @param promise The promise to terminate\n * @param callback The callback function to invoke\n */\nmodule.exports.resolvePromise = function(promise, callback) {\n    function resolveValue(value) {\n        if (callback) {\n            callback(null, value);\n        }\n    }\n\n    function resolveError(err) {\n        if (callback) {\n            callback(err, null);\n        }\n    }\n\n    promise.then(resolveValue).catch(resolveError);\n};\n\n/**\n * Combines the specified object with the properties defined in the values object, overwriting any existing values.\n * @param obj The object to combine the values with\n * @param values The objects to get the properties and values from, can be many arguments\n */\nmodule.exports.combine = function (obj, values) {\n    var argIdx = 1,\n        value,\n        property;\n\n    while (argIdx < arguments.length) {\n        value = arguments[argIdx];\n        for (property in value) {\n            if (value.hasOwnProperty(property)) {\n                obj[property] = value[property];\n            }\n        }\n        argIdx++;\n    }\n\n    return obj;\n};\n\nmodule.exports.isFunction = function(object) {\n    var getClass = {}.toString;\n\n    return object && getClass.call(object) === '[object Function]';\n};\n\n/**\n * Parses a JSON response checking for success on all changes.\n * @param result The JSON object to parse for success messages.\n * @returns {boolean} true if all changes were successful.\n */\nmodule.exports.wasSuccessful = function (result) {\n    var success = true,\n        idx,\n        len;\n\n    if (util.isArray(result)) {\n        for (idx = 0, len = result.length; idx < len; idx++) {\n            success = success && module.exports.wasSuccessful(result[idx]);\n        }\n    } else {\n        success = result.success !== 'undefined';\n    }\n    return success;\n};\n\n/**\n * Parses a JSON response looking for the errors in the result(s) returned.\n * @param results The results to look for errors in.\n * @returns {Array} Of errors found.\n */\nmodule.exports.parseErrors = function (results) {\n    var errors = [];\n\n    if (util.isArray(results)) {\n        results.forEach(function (result) {\n            if (result.error) {\n                errors.push(result.error);\n            }\n        });\n    } else {\n        if (results.error) {\n            errors.push(results.error);\n        } else {\n            //TODO this should not occur\n            console.log(\"UNPARSED\");\n            console.log(results);\n        }\n    }\n\n    //TODO actually find the error messages\n    return errors;\n};\n\n/**\n * Creates a String Value Array from the provided values.\n * @param values The values to convert to a String value Array.\n * @returns {Array} of strings.\n */\nmodule.exports.createStringValueArray = function (values) {\n    var result = [];\n\n    if (Array.isArray(values)) {\n        values.forEach(function (value) {\n            result.push(_asStringValue(value));\n        });\n    } else {\n        result.push(_asStringValue(values));\n    }\n\n    return result;\n};\n\nmodule.exports.valueForType = function(type, value) {\n    var result;\n\n    if (type === \"bool\") {\n        result = Boolean(value);\n    } else if (type === \"uint8\" || type === \"uint16\" || type === \"int8\" || type === \"int16\") {\n        result = Math.floor(value);\n\n        if (/^uint.*/.test(type) && result < 0) {\n            result = 0;\n        }\n    } else if (type === \"string\") {\n        result = String(value);\n    } else if (type === \"float\") {\n        result = Number(value);\n    } else if (type === \"list\") {\n        result = util.isArray(value) ? value : [];\n    } else {\n        result = value;\n    }\n\n    return result;\n};\n\nfunction _asStringValue(value) {\n    var result;\n\n    if (typeof(value) === 'string') {\n        result = value;\n    } else {\n        result = String(value);\n    }\n    return result;\n}\n\nmodule.exports.getStringValue = function(value, maxLength) {\n    var result = value || \"\";\n\n    if (maxLength && result.length > maxLength) {\n        result = result.substr(0, maxLength);\n    }\n    return result;\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/discovery.js":"\"use strict\";\n\nvar util = require(\"util\"),\n    Trait = require(\"traits\").Trait,\n    tApiMethod = require(\"./traits/tApiMethod\"),\n    tDescription = require(\"./traits/tDescription\"),\n    tPostProcessing = require(\"./traits/tPostProcessing\"),\n    apiTraits = {};\n\napiTraits.description = Trait.compose(\n    tApiMethod(\n        \"/description.xml\",\n        \"GET\",\n        \"1.0\",\n        \"All\",\n        \"application/xml\"\n    ),\n    tDescription(\"Returns an XML description of the Hue Bridge.\")\n);\n\napiTraits.upnpLookup = Trait.compose(\n    tApiMethod(\n        \"/api/nupnp\",\n        \"GET\",\n        \"1.0\",\n        \"All\"\n    ),\n    tDescription(\"Obtains the known Hue Bridges on the network from www.meethue.com\"),\n    tPostProcessing(_processUpnpBridgeResults)\n);\n\nmodule.exports = {\n    description: Trait.create(Object.prototype, apiTraits.description),\n    upnpLookup: Trait.create(Object.prototype, apiTraits.upnpLookup)\n};\n\nfunction _processUpnpBridgeResults(results) {\n    var bridges = [];\n\n    if (util.isArray(results)) {\n        results.forEach(function (bridge) {\n            bridges.push(bridgeResult(bridge));\n        });\n    } else {\n        bridges.push(bridgeResult(results));\n    }\n\n    return bridges;\n}\n\nfunction bridgeResult(bridge) {\n    return {\n        id: bridge.id,\n        name: bridge.name,\n        ipaddress: bridge.internalipaddress,\n        mac: bridge.macaddress\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/traits/tApiMethod.js":"\"use strict\";\n\nvar Trait = require(\"traits\").Trait,\n    ApiError = require(\"../../errors\").ApiError;\n\nfunction extractParameters(str) {\n    var parameters = [],\n        currentParameter = null,\n        currentChar,\n        idx = 0;\n\n    if (str) {\n        while (idx < str.length) {\n            currentChar = str.charAt(idx);\n\n            if (currentChar === \"<\") {\n                // The beginning of a parameter\n                currentParameter = \"\";\n            } else if (currentChar === \">\") {\n                // The end of a parameter, maybe\n                if (currentParameter !== null) {\n                    parameters.push(currentParameter);\n                    // Reset the current parameter\n                    currentParameter = null;\n                }\n            } else if (currentParameter !== null) {\n                // Append the character to the parameter name\n                currentParameter += currentChar;\n            }\n\n            idx += 1;\n        }\n    }\n\n    return parameters;\n}\n\nmodule.exports = function (path, method, version, permission, response) {\n    return Trait(\n        {\n            path: path,\n            method: method,\n            version: version,\n            permission: permission, //TODO may not be required as this represents the <username> variable in the path\n            response: response || \"application/json\",\n\n            pathParameters: function () {\n                if (!this.path) {\n                    throw new ApiError(\"The command has no path\");\n                }\n\n                return extractParameters(this.path);\n            },\n\n            getPath: function (values) {\n                var requiredParameters = this.pathParameters(),\n                    resolvedPath = this.path;\n\n                requiredParameters.forEach(function (reqParam) {\n                    if (values[reqParam] === undefined) {\n                        throw new ApiError(\"The required parameter '\" + reqParam + \"' was missing a value.\");\n                    }\n\n                    resolvedPath = resolvedPath.replace(\"<\" + reqParam + \">\", values[reqParam]);\n                });\n\n                return resolvedPath;\n            },\n\n            toString: function () {\n                var result = {\n                    \"path\": this.path,\n                    \"method\": this.method,\n                    \"version\": this.version\n                };\n\n                return JSON.stringify(result);\n            }\n        }\n    );\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/traits/tDescription.js":"\"use strict\";\n\nvar Trait = require(\"traits\").Trait,\n    ApiError = require(\"../../errors\").ApiError;\n\nmodule.exports = function (description) {\n    return Trait(\n        {\n            commandDescription : description\n        }\n    );\n};\n","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/traits/tPostProcessing.js":"\"use strict\";\n\nvar util = require(\"util\")\n    , Trait = require(\"traits\").Trait\n    , ApiError = require(\"../../errors\").ApiError\n    ;\n\nfunction validateFunction(fn) {\n    var result = [];\n\n    if (util.isArray(fn)) {\n        fn.forEach(function (actualFn) {\n            result = result.concat(validateFunction(actualFn));\n        });\n    } else {\n        if (typeof fn !== \"function\") {\n            throw new ApiError(\"The post processing function must be a function; \" + typeof fn);\n        }\n        result.push(fn);\n    }\n\n    return result;\n}\n\nmodule.exports = function (fn) {\n    var processingFunctions;\n\n    if (arguments.length === 0) {\n        throw new ApiError(\"At least one post processing functions must be provided\");\n    }\n\n    processingFunctions = validateFunction(Array.prototype.slice.call(arguments));\n\n    return Trait({\n        \"postProcessing\": processingFunctions\n    });\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/index.js":"\"use strict\";\n\nvar Q = require(\"q\")\n    , deepExtend = require(\"deep-extend\")\n    , http = require(\"./httpPromise\")\n    , ApiError = require(\"./errors\").ApiError\n    , utils = require(\"./utils\")\n    , lightsApi = require(\"./commands/lights-api\")\n    , sensorsApi = require(\"./commands/sensors-api\")\n    , groupsApi = require(\"./commands/groups-api\")\n    , schedulesApi = require(\"./commands/schedules-api\")\n    , scenesApi = require(\"./commands/scenes-api\")\n    , configurationApi = require(\"./commands/configuration-api\")\n    , infoApi = require(\"./commands/info-api\")\n    , scheduledEvent = require(\"./scheduledEvent\")\n    , bridgeDiscovery = require(\"./bridge-discovery\")\n    , lightState = require(\"./lightstate\")\n    , rgb = require(\"./rgb\")\n    ;\n\nfunction HueApi(config) {\n    this._config = config;\n}\n\nmodule.exports = function (host, username, timeout, port) {\n    var config = {\n        hostname: host,\n        username: username,\n        timeout: timeout || 10000,\n        port: port || 80\n    };\n\n    return new HueApi(config);\n};\n\n\n/**\n * Gets the version data for the Philips Hue Bridge.\n *\n * @param cb An optional callback function if you don't want to be informed via a promise.\n * @returns {Q.promise} A promise will be provided that will resolve to the version data for the bridge, or {null} if a\n * callback was provided.\n */\nHueApi.prototype.getVersion = function (cb) {\n    var promise = this.config()\n        .then(function (data) {\n            return {\n                name: data.name,\n                version: {\n                    api: data.apiversion,\n                    software: data.swversion\n                }\n            };\n        });\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.version = HueApi.prototype.getVersion;\n\n\n/**\n * Loads the description for the Philips Hue.\n *\n * @param cb An optional callback function if you don't want to be informed via a promise.\n * @return {Q.promise} A promise that will be provided with a description object, or {null} if a callback was provided.\n */\nHueApi.prototype.description = function (cb) {\n    var promise = bridgeDiscovery.description(this._config.hostname);\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getDescription = HueApi.prototype.description;\n\n\n/**\n * Reads the bridge configuration and returns it as a JSON object.\n *\n * @param cb An optional callback function to use if you do not want to use the promise for results.\n * @return {Q.promise} A promise with the result, or <null> if a callback function was provided.\n */\nHueApi.prototype.config = function (cb) {\n    var options = this._defaultOptions(),\n        promise = http.invoke(configurationApi.getConfiguration, options);\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getConfig = HueApi.prototype.config;\n\n\n/**\n * Obtains the complete state for the Bridge. This is considered to be a very expensive operation and should not be invoked\n * frequently. The results detail all config, users, groups, schedules and lights for the system.\n *\n * @param cb An optional callback function if you don't want to be informed via a promise.\n * @returns {Q.promise} A promise with the result, or {null} if a callback function was provided\n */\nHueApi.prototype.getFullState = function (cb) {\n    var options = this._defaultOptions(),\n        promise = http.invoke(configurationApi.getFullState, options);\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.fullState = HueApi.prototype.getFullState;\n\n\n/**\n * Allows a new user/device to be registered with the Philips Hue Bridge. This will return the name of the user that was\n * created by the function call.\n *\n * This function does not require the HueApi to have been initialized with a host or username. It does however require\n * the end user to have pressed the link button on the bridge, before invoking this function.\n *\n * @param host The hostname or IP Address of the Hue Bridge.\n * @param deviceDescription The description for the user/device that is being registered. This is a human readable\n * description of the user/device. If one is not provided then a default will be set.\n * @param cb An optional callback function to use if you do not want a promise returned.\n * @return {Q.promise} A promise with the result, or <null> if a callback was provided.\n */\nHueApi.prototype.registerUser = function (host, deviceDescription, cb) {\n    var options = {\n            host: host,\n            values: {}\n        }\n        , devicetype = \"Node.js API\"\n        , promise\n        ;\n\n    if (utils.isFunction(deviceDescription)) {\n        options.values.devicetype = devicetype;\n        cb = deviceDescription;\n    } else {\n        options.values.devicetype = deviceDescription || devicetype\n    }\n\n    promise = http.invoke(configurationApi.createUser, options);\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.createUser = HueApi.prototype.registerUser;\n\n\n/**\n * Presses the Link Button on the Bridge (without the user actually having to do it). If successful then {true} will be\n * returned as the result.\n *\n * @param cb An optional callback function to use if you do not want to use the promise returned.\n * @return {Q.promise} A promise with the result, or <null> if a callback was provided.\n */\nHueApi.prototype.pressLinkButton = function (cb) {\n    var options = this._defaultOptions(),\n        promise;\n\n    promise = _setConfigurationOptions(options, {\"linkbutton\": true});\n    if (!promise) {\n        promise = http.invoke(configurationApi.modifyConfiguration, options);\n    }\n    return utils.promiseOrCallback(promise, cb);\n};\n\n\n/**\n * Deletes an existing user from the Phillips Hue Bridge.\n *\n * @param username The username of the user to delete.\n * @param cb An optional callback function to use if you do not want to get the result via a promise chain.\n * @returns {Q.promise} A promise with the result of the deletion, or <null> if a callback was provided.\n */\nHueApi.prototype.deleteUser = function (username, cb) {\n    var options = this._defaultOptions(),\n        promise;\n\n    promise = _setDeleteUserOptions(options, username);\n    if (!promise) {\n        promise = http.invoke(configurationApi.deleteUser, options);\n    }\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.unregisterUser = HueApi.prototype.deleteUser;\n\n\n/**\n * Obtain a list of registered \"users\" or \"devices\" that can interact with the Philips Hue.\n *\n * @param cb An optional callback function if you do not want to use the promise to obtain the results.\n * @return A promise that will provide the results of registered users, or <null> if a callback was provided.\n */\nHueApi.prototype.registeredUsers = function (cb) {\n    function processUsers(result) {\n        var list = result.whitelist,\n            devices = [];\n\n        if (list) {\n            Object.keys(list).forEach(function (key) {\n                var device;\n                if (list.hasOwnProperty(key)) {\n                    device = list[key];\n                    devices.push(\n                        {\n                            \"name\": device.name,\n                            \"username\": key,\n                            \"created\": device[\"create date\"],\n                            \"accessed\": device[\"last use date\"]\n                        }\n                    );\n                }\n            });\n        }\n        return {\"devices\": devices};\n    }\n\n    var promise = this.config().then(processUsers);\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getRegisteredUsers = HueApi.prototype.registeredUsers;\n\n\n/**\n * Obtains the details of the individual sensors that are attached to the Philips Hue.\n *\n * @param cb An optional callback function to use if you do not want a promise returned.\n * @return A promise that will be provided with the lights object, or {null} if a callback function was provided.\n */\nHueApi.prototype.sensors = function (cb) {\n    var options = this._defaultOptions(),\n        promise;\n\n    promise = http.invoke(sensorsApi.getAllSensors, options);\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getSensors = HueApi.prototype.sensors;\n\n/**\n * Obtains the details of the individual lights that are attached to the Philips Hue.\n *\n * @param cb An optional callback function to use if you do not want a promise returned.\n * @return A promise that will be provided with the lights object, or {null} if a callback function was provided.\n */\nHueApi.prototype.lights = function (cb) {\n    var options = this._defaultOptions(),\n      promise;\n\n    promise = http.invoke(lightsApi.getAllLights, options);\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getLights = HueApi.prototype.lights;\n\n\n/**\n * Obtains the status of the specified light.\n *\n * @param id The id of the light as an integer, this value will be parsed into an integer value so can be a {String} or\n * {Number} value.\n * @param cb An optional callback function to use if you do not want a promise returned.\n * @return A promise that will be provided with the light status, or {null} if a callback function was provided.\n */\nHueApi.prototype.lightStatus = function (id, cb) {\n    var options = this._defaultOptions(),\n        promise;\n\n    promise = _setLightIdOption(options, id);\n\n    if (!promise) {\n        promise = http.invoke(lightsApi.getLightAttributesAndState, options);\n    }\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getLightStatus = HueApi.prototype.lightStatus;\n\n\nHueApi.prototype.lightStatusWithRGB = function(id, cb) {\n    var promise = this.lightStatus(id);\n\n    promise = promise.then(function(light) {\n        var state = light.state\n          , x = state.xy[0]\n          , y = state.xy[1]\n          , brightness = state.bri / 254\n          ;\n        return deepExtend({state: {rgb: rgb.convertXYtoRGB(x, y, brightness)}}, light);\n    });\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getLightStatusWithRGB = HueApi.prototype.lightStatusWithRGB;\n\n/**\n * Obtains the new lights found by the bridge, dependant upon the last search.\n *\n * @param cb An optional callback function to use if you do not want a promise returned.\n * @return A promise that will be provided with the new lights search result, or {null} if a callback function was provided.\n */\nHueApi.prototype.newLights = function (cb) {\n    var options = this._defaultOptions(),\n        promise = http.invoke(lightsApi.getNewLights, options);\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getNewLights = HueApi.prototype.newLights;\n\n\n/**\n * Starts a search for new lights.\n *\n * @param cb An optional callback function to use if you do not want a promise returned.\n * @return A promise that will be provided with the new lights, or {null} if a callback function was provided.\n */\nHueApi.prototype.searchForNewLights = function (cb) {\n    var options = this._defaultOptions(),\n        promise = http.invoke(lightsApi.searchForNewLights, options);\n\n    return utils.promiseOrCallback(promise, cb);\n};\n\n\n/**\n * Sets the name of a light on the Bridge.\n *\n * @param id The ID of the light to set the name for.\n * @param name The name to apply to the light.\n * @param cb An optional callback function to use if you do not want a promise returned.\n * @return A promise that will be provided with the results of setting the name, or {null} if a callback function was provided.\n */\nHueApi.prototype.setLightName = function (id, name, cb) {\n    var options = this._defaultOptions(),\n        promise;\n\n    promise = _setLightIdOption(options, id);\n\n    options.values = {\n        \"name\": name\n    };\n\n    if (!promise) {\n        promise = http.invoke(lightsApi.renameLight, options);\n    }\n    return utils.promiseOrCallback(promise, cb);\n};\n\n\n/**\n * Sets the light state to the provided values.\n *\n * @param id The id of the light which is an integer or a value that can be parsed into an integer value.\n * @param stateValues {Object} containing the properties and values to set on the light.\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise that will set the specified state on the light, or {null} if a callback was provided.\n */\nHueApi.prototype.setLightState = function (id, stateValues, cb) {\n    var promise = this._getLightStateOptions(id, stateValues)\n        .then(function (options) {\n            return http.invoke(lightsApi.setLightState, options);\n        });\n    return utils.promiseOrCallback(promise, cb);\n};\n\n\n/**\n * Sets the light state to the provided values for an entire group.\n *\n * @param id The id of the group which is an integer or a value that can be parsed into an integer value.\n * @param stateValues {Object} containing the properties and values to set on the light.\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return {Q.promise} A promise that will set the specified state on the group, or {null} if a callback was provided.\n */\nHueApi.prototype.setGroupLightState = function (id, stateValues, cb) {\n    var promise = this._getGroupLightStateOptions(id, stateValues)\n        .then(function (options) {\n            return http.invoke(groupsApi.setGroupState, options);\n        });\n    return utils.promiseOrCallback(promise, cb);\n};\n\n\n/**\n * Obtains all the groups from the Hue Bridge as an Array of {id: {*}, name: {*}} objects.\n *\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise that will obtain the groups, or {null} if a callback was provided.\n */\nHueApi.prototype.groups = function (cb) {\n    var options = this._defaultOptions(),\n        promise = http.invoke(groupsApi.getAllGroups, options);\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getGroups = HueApi.prototype.groups;\nHueApi.prototype.getAllGroups = HueApi.prototype.groups;\n\n\n/**\n * Obtains all the Luminaires from the Hue Bridge as an Array of {id: {*}, name: {*}} objects.\n *\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise that will obtain the luminaires, or {null} if a callback was provided.\n */\nHueApi.prototype.luminaires = function (cb) {\n    var promise = this._filterGroups(\"Luminaire\");\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getLuminaires = HueApi.prototype.luminaires;\n\n\n/**\n * Obtains all the LightSources from the Hue Bridge as an Array of {id: {*}, name: {*}} objects.\n *\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise that will obtain the lightsources, or {null} if a callback was provided.\n */\nHueApi.prototype.lightSources = function (cb) {\n    var promise = this._filterGroups(\"Lightsource\");\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getLightSources = HueApi.prototype.lightSources;\n\n\n/**\n * Obtains all the LightGroups from the Hue Bridge as an Array of {id: {*}, name: {*}} objects.\n *\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise that will obtain the LightGroups, or {null} if a callback was provided.\n */\nHueApi.prototype.lightGroups = function (cb) {\n    var promise = this._filterGroups(\"LightGroup\");\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getLightGroups = HueApi.prototype.lightGroups;\n\n\n/**\n * Obtains the details for a specified group in a format of {id: {*}, name: {*}, lights: [], lastAction: {*}}.\n *\n * @param id {Number} or {String} which is the id of the group to get the details for.\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise that will set the specified state on the light, or {null} if a callback was provided.\n */\nHueApi.prototype.getGroup = function (id, cb) {\n    var options = this._defaultOptions(),\n        promise;\n\n    //TODO find a way to make this a normal post processing action in the groups-api, the id from the call needs to be injected...\n    function processGroupResult(group) {\n        var result = {\n            id: String(id),\n            name: group.name,\n            type: group.type,\n            lights: group.lights,\n            lastAction: group.action\n        };\n\n        if (group.type === \"Luminaire\" && group.modelid) {\n            result.modelid = group.modelid;\n        }\n\n        return result;\n    }\n\n    promise = _setGroupIdOption(options, id);\n    if (!promise) {\n        promise = http.invoke(groupsApi.getGroupAttributes, options).then(processGroupResult);\n    }\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.group = HueApi.prototype.getGroup;\n\n\n/**\n * Updates a light group to the specified name and/or lights ids. The name and light ids can be specified independently or\n * together when calling this function.\n *\n * @param id The id of the group to update the name and/or light ids associated with it.\n * @param name {String} The name of the group\n * @param lightIds {Array} An array of light ids to be assigned to the group. If any of the ids are not present in the\n * bridge the creation will fail with an error being produced.\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise with a result of <true> if the update was successful, or null if a callback was provided.\n */\nHueApi.prototype.updateGroup = function (id, name, lightIds, cb) {\n    var options = this._defaultOptions(),\n        parameters = [].slice.call(arguments, 1),\n        promise;\n\n    options.values = {};\n    promise = _setGroupIdOptionForModification(options, id);\n\n    // Due to name and lightIds being \"optional\" we have to re-parse the arguments to get the right ones\n    parameters.forEach(function (param) {\n        if (param instanceof Function) {\n            cb = param;\n        } else if (Array.isArray(param)) {\n            options.values.lights = utils.createStringValueArray(param);\n        } else if (param === undefined || param === null) {\n            // Ignore it\n        } else {\n            options.values.name = param;\n        }\n    });\n\n    if (!promise && !options.values.lights && !options.values.name) {\n        promise = _errorPromise(\"A name or array of lightIds must be provided\");\n    }\n\n    if (!promise) {\n        promise = http.invoke(groupsApi.setGroupAttributes, options);\n    }\n\n    return utils.promiseOrCallback(promise, cb);\n};\n\n\n/**\n * Creates a new light Group.\n *\n * @param name The name of the group that we are creating, limited to 16 characters.\n * @param lightIds {Array} of ids for the lights to be included in the group.\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return {*} A promise that will return the id of the group that was created, or null if a callback was provided.\n */\nHueApi.prototype.createGroup = function (name, lightIds, cb) {\n    var options = this._defaultOptions(),\n        promise;\n\n    options.values = {\n        name: name,\n        lights: utils.createStringValueArray(lightIds)\n    };\n\n    promise = http.invoke(groupsApi.createGroup, options);\n    return utils.promiseOrCallback(promise, cb);\n};\n\n\n/**\n * Deletes a group with the specified id, returning <true> if the action was successful.\n *\n * @param id The id of the group to delete.\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return {*} A promise that will return <true> if the deletion was successful, or null if a callback was provided.\n */\nHueApi.prototype.deleteGroup = function (id, cb) {\n    var options = this._defaultOptions(),\n        promise = _setGroupIdOptionForModification(options, id);\n\n    if (!promise) {\n        promise = http.invoke(groupsApi.deleteGroup, options);\n    }\n    return utils.promiseOrCallback(promise, cb);\n};\n\n\n/**\n * Gets the schedules on the Bridge, as an array of {\"id\": {String}, \"name\": {String}} objects.\n *\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise that will return the results or <null> if a callback was provided.\n */\nHueApi.prototype.schedules = function (cb) {\n    var options = this._defaultOptions(),\n        promise = http.invoke(schedulesApi.getAllSchedules, options);\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getSchedules = HueApi.prototype.schedules;\n\n\n/**\n * Gets the specified schedule by id, which is in an identical format the the Hue API documentation, with the addition\n * of an \"id\" value for the schedule.\n *\n * @param id The id of the schedule to retrieve.\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @returns A promise that will return the results or <null> if a callback was provided.\n */\nHueApi.prototype.getSchedule = function (id, cb) {\n    var options = this._defaultOptions()\n      , promise = _setScheduleIdOption(options, id)\n      ;\n\n    function parseResults(result) {\n        result.id = id;\n        return result;\n    }\n\n    if (!promise) {\n        promise = http.invoke(schedulesApi.getSchedule, options).then(parseResults);\n    }\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.schedule = HueApi.prototype.getSchedule;\n\n\n/**\n * Creates a one time scheduled event. The results from this function is the id of the created schedule. The bridge only\n * supports 100 schedules, so once they are triggered, they are removed from the bridge.\n *\n * @param schedule {ScheduledEvent}\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise that will return the id value of the schedule that was created, or <null> if a callback was provided.\n */\nHueApi.prototype.scheduleEvent = function (schedule, cb) {\n    return this._createSchedule(schedule, cb);\n};\nHueApi.prototype.createSchedule = HueApi.prototype.scheduleEvent;\n\n\n/**\n * Deletes a schedule by id, returning {true} if the deletion was successful.\n *\n * @param id of the schedule\n * @param cb An option callback function to use if you do not want to use a promise for the results.\n * @return {Q.promise} A promise that will return the result of the deletion, or <null> if a callback was provided.\n */\nHueApi.prototype.deleteSchedule = function (id, cb) {\n    var options = this._defaultOptions()\n      , promise = _setScheduleIdOption(options, id)\n      ;\n\n    if (!promise) {\n        promise = http.invoke(schedulesApi.deleteSchedule, options);\n    }\n    return utils.promiseOrCallback(promise, cb);\n};\n\n\n/**\n * Updates an existing schedule event with the provided details.\n *\n * @param id The id of the schedule being updated.\n * @param schedule The object containing the details to update for the existing schedule event.\n * @param cb An optional callback function to use if you do not want to deal with a promise for the results.\n * @return {Q.promise} A promise that will return the result, or <null> if a callback was provided.\n */\nHueApi.prototype.updateSchedule = function (id, schedule, cb) {\n    var options = this._defaultOptions()\n      , promise\n      ;\n\n    promise = _setScheduleIdOption(options, id);\n    if (!promise) {\n        promise = _setScheduleOptionsForUpdate(options, schedule);\n    }\n\n    if (!promise) {\n        promise = http.invoke(schedulesApi.setScheduleAttributes, options);\n    }\n\n    return utils.promiseOrCallback(promise, cb);\n};\n\n\n/**\n * Gets the scenes on the Bridge, as an array of {\"id\": {String}, \"name\": {String}, \"lights\": {Array}, \"active\": {Boolean}}\n * objects.\n *\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise that will return the results or <null> if a callback was provided.\n */\nHueApi.prototype.scenes = function (cb) {\n    var promise = this._scenes()\n        .then(function (result) {\n            var scenes = [];\n\n            Object.keys(result).forEach(function (id) {\n                var scene = result[id]\n                  , enrichedScene = deepExtend({}, scene)\n                  ;\n\n                enrichedScene.id = id;\n                scenes.push(enrichedScene);\n            });\n            return scenes;\n        });\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getScenes = HueApi.prototype.scenes;\n\n\n/**\n * Obtains a scene by a given id.\n * @param sceneId {String} The id of the scene to obtain.\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise that will return the scene or <null> if a callback was provided.\n */\nHueApi.prototype.scene = function (sceneId, cb) {\n    var options = this._defaultOptions()\n      , promise = _setSceneIdOption(options, sceneId)\n      ;\n\n    if (!promise) {\n      // No errors in sceneId\n      promise = http.invoke(scenesApi.getScene, options)\n        .then(function(data) {\n          data.id = sceneId;\n          return data;\n        })\n    }\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.getScene = HueApi.prototype.scene;\n\n/**\n * Deletes a Scene (that is stored inside the bridge, not in the lights).\n * @param sceneId The ID for the scene to delete\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @returns {*} A promise that will return the result from deleting the scene or null if a callback was provided.\n */\nHueApi.prototype.deleteScene = function(sceneId, cb) {\n    var options = this._defaultOptions()\n      , promise = _setSceneIdOption(options, sceneId)\n      ;\n\n    if (!promise) {\n        // No errors in sceneId\n        promise = http.invoke(scenesApi.deleteScene, options);\n    }\n\n    return utils.promiseOrCallback(promise, cb);\n};\n\n/**\n * Creates a new Scene.\n * When the scene is created, it will store the current state of the lights and will use those \"current\" settings\n * when the scene is recalled/activated later.\n *\n * There are two variants to this function, one that accepts lightIds and a name and another that takes a Scene object.\n * The former is to maintain backwards compatibility with the 1.2.x version of this library.\n *\n * @param lightIds {Array} of ids for the lights to be included in the scene.\n * @param name {String} The name of the scene to be created. If one is not provided, then the id of the scene will become the name.\n *\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return {*} A promise that will return the id of the scene that was created (as well as the values that make up the scene),\n * or null if a callback was provided.\n */\nHueApi.prototype.createScene = function (scene, cb) {\n    var self = this;\n\n    if (Array.isArray(arguments[0])) {\n        return self.createBasicScene(arguments[0], arguments[1], arguments[2]);\n    } else {\n        return self.createAdvancedScene(arguments[0], arguments[1]);\n    }\n};\n\n/**\n * Provides backwards compatibility for < 1.11.x versions of the Hue Bridge Firmware.\n * @param lightIds\n * @param name\n * @param cb\n * @returns {*}\n */\nHueApi.prototype.createBasicScene = function (lightIds, name, cb) {\n    var self = this\n      , options = self._defaultOptions()\n      , promise\n      ;\n\n    options.values = {\n        name: name,\n        lights: utils.createStringValueArray(lightIds),\n        recycle: false\n    };\n\n    promise = http.invoke(scenesApi.createScene, options);\n    return utils.promiseOrCallback(promise, cb);\n};\n\n/**\n * Provides scene creation for >= 1.11.x firmware versions of the Hue Bridge.\n * @param scene The Scene object containing the details of the scene to be created.\n * @param cb An optional callback function to use if you do not want to use a promise chain for the results.\n * @returns {*}\n */\nHueApi.prototype.createAdvancedScene = function(scene, cb) {\n    var self = this\n      , options = self._defaultOptions()\n      , myScene = deepExtend({recycle: false}, scene)\n      , promise\n      ;\n\n    //TODO validate the options object\n    options.values = myScene;\n\n    promise = http.invoke(scenesApi.createScene, options);\n    return utils.promiseOrCallback(promise, cb);\n};\n\n//TODO scene updates are now done as two different calls one for name and lights (and possible store current state) and a second of just setting individual light states\n/**\n * Update the lights and/or name associated with a scene (or will create a new one if the\n * sceneId is not present in the bridge).\n *\n * @param sceneId {String} The id for the scene in the bridge\n * @param scene The configuration of the scene with the details to modify, which can be either a name or an array of\n * light ids.\n * @param storeLightState {Boolean} flag to save the current light state of the lights in the scene.\n *\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return {*} A promise that will return the id of the scene that was updated and the light ids that are now set,\n * or null if a callback was provided.\n */\nHueApi.prototype.updateScene = function (sceneId, scene, storeLightState, cb) {\n    var self = this\n        , options = self._defaultOptions()\n        , storeState = !! storeLightState\n        , promise = _setSceneIdOption(options, sceneId)\n        ;\n\n    if (!promise) {\n        // No errors in sceneId\n\n        //TODO validate that we have at least one parameter to modify before calling\n\n        if (utils.isFunction(storeLightState)) {\n            cb = storeLightState;\n            storeState = false;\n        }\n\n        options.values = {};\n\n        // Only set the storelightstate to true, as the bridge does not accept a false value for this in version 1.11.0\n        if (storeState) {\n            options.values.storelightstate = true;\n        }\n\n        if (scene) {\n            if (scene.lights) {\n                options.values.lights = utils.createStringValueArray(scene.lights);\n            }\n\n            if (scene.name) {\n                options.values.name = scene.name;\n            }\n        }\n        promise = http.invoke(scenesApi.modifyScene, options);\n    }\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.modifyScene = HueApi.prototype.updateScene;\n\n/**\n * Modifies the light state of one of the lights in a scene.\n *\n * @param sceneId The scene id, which if it does not exist a new scene will be created.\n * @param lightId integer The id of light that is having the state values set.\n * @param stateValues {Object} containing the properties and values to set on the light.\n *\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise that will return the state values on the light, or {null} if a callback was provided.\n */\nHueApi.prototype.setSceneLightState = function (sceneId, lightId, stateValues, cb) {\n    var promise;\n\n    promise = this._getLightStateOptions(lightId, stateValues)\n        .then(function (options) {\n            // Need to set id and lightId correctly, the above call treats the lightId as the id\n            options.lightId = options.id;\n            options.id = sceneId;\n\n            return http.invoke(scenesApi.modifyLightState, options);\n        });\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.updateSceneLightState = HueApi.prototype.setSceneLightState;\nHueApi.prototype.modifySceneLightState = HueApi.prototype.setSceneLightState;\n\n\n/**\n * Helper-function that recalls a scene for a group using setGroupLightState. Reason for existence is simplicity for\n * user.\n *\n * @param sceneId The id of the scene to activate, which is an integer or a value that can be parsed into an integer value.\n * @param groupIdFilter An optional group filter to apply to the scene, to select a sub set of the lights in the scene. This can\n * be {null} or {undefined} to not apply a filter.\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return A promise that will set activate the scene, or {null} if a callback was provided.\n */\nHueApi.prototype.activateScene = function (sceneId, groupIdFilter, cb) {\n    var promise;\n\n    if (utils.isFunction(groupIdFilter)) {\n        cb = groupIdFilter;\n        groupIdFilter = null;\n    }\n\n    try {\n        groupIdFilter = Number(groupIdFilter, 10);\n        if (isNaN(groupIdFilter)) {\n            groupIdFilter = 0;\n        }\n    } catch (err) {\n        groupIdFilter = 0;\n    }\n\n    promise = this.setGroupLightState(groupIdFilter, {scene: sceneId});\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.recallScene = HueApi.prototype.activateScene;\n\n\n// TODO this is flawed as the name can be in multiple scenes, all of which are active...\n///**\n// * Helper function that recalls a scene for a group using setGroupLightState. The id is extracted from the name, if\n// * multiple ids is encountered which often is the case when a scene is edited via an ios/android app the last one is\n// * used. Currently this is the scene last saved this is an assumption bases on undocumented handling.\n// *\n// * @param id The id of the light which is an integer or a value that can be parsed into an integer value.\n// * @param stateValues {Object} containing the properties and values to set on the light.\n// * @param cb An optional callback function to use if you do not want to use a promise for the results.\n// * @return A promise that will set the specified state on the light, or {null} if a callback was provided.\n// */\n////TODO rename\n//HueApi.prototype.recallSceneByName = function (groupId, sceneName, cb) {\n//    var self = this\n//        , deferred = Q.defer()\n//        , scenes = {}\n//        ;\n//\n//    //TODO this will not function as expected\n//    self.scenes()\n//        .then(function (sceneArray) {\n//            sceneArray.forEach(function (scene) {\n//                scenes[scene.name] = scene.id;\n//            });\n//\n//            if (typeof scenes[sceneName] !== 'undefined') {\n//                self.setGroupLightState(groupId, {scene: scenes[sceneName]})\n//                    .then(function (result) {\n//                        deferred.resolve(result);\n//                    });\n//            }\n//        }).done();\n//\n//    return utils.promiseOrCallback(deferred.promise, cb);\n//};\n\n\n/**\n * Obtains all the allowed timezones from the bridge.\n *\n * @param cb An optional callback function to use if you do not want to use a promise for the results.\n * @return {*} A promise that will return the id of the scene that was created, or null if a callback was provided.\n */\nHueApi.prototype.getTimezones = function (cb) {\n    var options = this._defaultOptions()\n        , promise = http.invoke(infoApi.getAllTimezones, options)\n        ;\n\n    return utils.promiseOrCallback(promise, cb);\n};\nHueApi.prototype.timezones = HueApi.prototype.getTimezones;\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// PRIVATE FUNCTIONS\n////////////////////////////////////////////////////////////////////////////////////////////////\n\nHueApi.prototype._getConfig = function () {\n    return this._config;\n};\n\n/**\n * Creates a default options object for connecting with a Hue Bridge.\n *\n * @returns {{host: *, username: *, timeout: *}}\n * @private\n */\nHueApi.prototype._defaultOptions = function () {\n    var config = this._getConfig();\n\n    return {\n        host: config.hostname,\n        username: config.username,\n        timeout: config.timeout,\n        port: config.port\n    };\n};\n\nHueApi.prototype._filterGroups = function (type) {\n    var self = this;\n\n    return self.groups()\n        .then(function (groups) {\n            var results = [];\n\n            if (groups) {\n                groups.forEach(function (group) {\n                    if (group.type === type) {\n                        results.push(group);\n                    }\n                })\n            }\n\n            return results;\n        });\n};\n\nHueApi.prototype._scenes = function () {\n    var options = this._defaultOptions();\n    return http.invoke(scenesApi.getAllScenes, options);\n};\n\n/**\n * Obtains the lights in a group and separates them into sub groups based on the model.\n * @param groupId The id of the group.\n * @returns {Object} A map of modelid to and array of lights that have that model.\n * @private\n */\nHueApi.prototype._getGroupLightsByType = function (groupId) {\n    var self = this;\n\n    return Q.all(\n        [\n            self.getGroup(groupId),\n            self.getLights()\n        ])\n        .spread(function (group, allLights) {\n            var map = {}\n                , lightMap = getLightsModelMap(allLights)\n                ;\n\n            if (group && group.lights) {\n                group.lights.forEach(function(lightId) {\n                    var modelid = lightMap[lightId];\n\n                    if (map[modelid]) {\n                        map[modelid].push(lightId);\n                    } else {\n                        map[modelid] = [lightId];\n                    }\n                });\n            }\n\n            return map;\n        });\n};\n\n/**\n * Generates the light state options for a group\n * @param groupId The group to apply the state values to\n * @param stateValues The state of the lights to apply\n * @returns {Q.promise} That will resolve to a set of options for the group or an array of options to apply subsets of\n * lights in the group.\n * @private\n */\nHueApi.prototype._getGroupLightStateOptions = function (groupId, stateValues) {\n    var self = this\n        , options = self._defaultOptions()\n        , state\n        , deferred\n        , promise\n        ;\n\n    promise = _setGroupIdOption(options, groupId);\n\n    if (!promise) {\n        // No errors in the group id\n\n        if (lightState.isLightState(stateValues)) {\n            state = stateValues;\n        } else {\n            state = lightState.create(stateValues);\n        }\n\n        if (state.hasRGB()) {\n            //TODO RGB is tricky with groups, need to break the group into types and perform conversion\n            // Get all lights in the group,\n            // separate into types based on model\n            // create multiple states per model\n            // return a map of sub groups to states required\n\n            deferred = Q.defer();\n            deferred.reject(new ApiError(\"RGB state is not supported for groups yet\"));\n            promise = deferred.promise;\n\n            //// Separate the lights into models and apply the state to each type\n            //promise = self._getGroupLightsByType(groupId)\n            //    .then(function(groupLightsMap) {\n            //        var models = Object.keys(groupLightsMap)\n            //            , result = []\n            //            ;\n            //\n            //        models.forEach(function(model) {\n            //            var newState = state.copy();\n            //            newState.applyRGB(model);\n            //\n            //            result.push({\n            //                modelid: model,\n            //                lights: groupLightsMap[model],\n            //                state: newState\n            //            });\n            //        });\n            //\n            //        return result;\n            //    })\n            //    .then(function(subgroupsWithState) {\n            //       //TODO need to create options\n            //    });\n        } else {\n            options.values = state.payload();\n\n            deferred = Q.defer();\n            deferred.resolve(options);\n            promise = deferred.promise;\n        }\n    }\n\n    return promise;\n};\n\nHueApi.prototype._getLightStateOptions = function (lightId, stateValues) {\n    var self = this\n        , options = self._defaultOptions()\n        , deferred\n        , state\n        , promise\n        ;\n\n    promise = _setLightIdOption(options, lightId);\n\n    if (!promise) {\n        // We have not errored, so check if we need to convert an rgb value\n\n        if (lightState.isLightState(stateValues)) {\n            state = stateValues;\n        } else {\n            state = lightState.create(stateValues);\n        }\n\n        if (state.hasRGB()) {\n            promise = self.lightStatus(lightId)\n                .then(function (lightDetails) {\n                    state = state.applyRGB(lightDetails.modelid);\n                    options.values = state.payload();\n\n                    return options;\n                });\n        } else {\n            options.values = state.payload();\n\n            deferred = Q.defer();\n            deferred.resolve(options);\n\n            promise = deferred.promise;\n        }\n\n    }\n\n    return promise;\n};\n\n/**\n * Creates a new schedule in the Hue Bridge.\n *\n * @param schedule The schedule object to create.\n * @param cb An optional callback if you do not want to use the promise for results.\n * @returns {Q.promise} A promise with the creation results, or <null> if a callback was provided.\n * @private\n */\nHueApi.prototype._createSchedule = function (schedule, cb) {\n    var options = this._defaultOptions(),\n        promise = _setScheduleOptionsForCreation(options, schedule);\n\n    if (!promise) {\n        promise = http.invoke(schedulesApi.createSchedule, options);\n    }\n    return utils.promiseOrCallback(promise, cb);\n};\n\n/**\n * Validates and then injects the username to be deleted into the options.\n *\n * @param options The options to inject the value into.\n * @param username The username to delete.\n * @returns {Q.promise} A promise containing the error(s) if there were any, otherwise <null>.\n * @private\n */\nfunction _setDeleteUserOptions(options, username) {\n    var errorPromise = null;\n\n    //TODO perform a lookup for the user before we attempt to delete it??\n    if (!username) {\n        errorPromise = _errorPromise(\"A username to delete must be specified.\");\n    }\n    options.username2 = username;\n\n    return errorPromise;\n}\n\n/**\n * Validates and injects the configuration options to set for the Hue Bridge into the provided options.\n *\n * @param options The options to inject into.\n * @param values The values that we wish to modify on the bridge.\n * @private\n */\nfunction _setConfigurationOptions(options, values) {\n    var errorPromise = null,\n        validOptionFound = false;\n\n    // Use the API specification to check all required values have been provided.\n    Object.keys(configurationApi.modifyConfiguration.bodyArguments).forEach(function (value) {\n        var option = configurationApi.modifyConfiguration.bodyArguments[value];\n\n        // Check to see if we have at least one option being set\n        if (!validOptionFound && values[value]) {\n            validOptionFound = true;\n        }\n\n        // Check that we have all the required options being provided\n        if (!option.optional) {\n            // Check that the value has been provided\n            if (!errorPromise && !values[value]) {\n                errorPromise = _errorPromise(\"A required configuration option '\" + value + \"' was not provided.\");\n            }\n        }\n    });\n\n    if (!errorPromise) {\n        if (!validOptionFound) {\n            errorPromise = _errorPromise(\"No valid options for the bridge configuration were specified.\");\n        } else {\n            options.values = values;\n        }\n    }\n\n    return errorPromise;\n}\n\nfunction getLightsModelMap(lightsArray) {\n    var map = {};\n\n    if (Array.isArray(lightsArray)) {\n        lightsArray.forEach(function(light) {\n            map[light.id] = light.modelid;\n        });\n    }\n\n    return map;\n}\n\n/**\n * Validates and then injects the 'id' into the options for a light in the bridge.\n *\n * @param options The options to add the 'id' to.\n * @param id The id of the light\n * @return {Q.promise} A promise that will throw the error if there was one, otherwise <null>.\n * @private\n */\nfunction _setLightIdOption(options, id) {\n    var errorPromise = null;\n\n    if (!_isLightIdValid(id)) {\n        errorPromise = _errorPromise(\"The light id '\" + id + \"' is not valid for this Hue Bridge.\");\n    } else {\n        options.id = id;\n    }\n\n    return errorPromise;\n}\n\n/**\n * Validates and then injects the 'id' into the options for a group in the bridge.\n *\n * @param options The options to add the 'id' to.\n * @param id The id of the group\n * @return {Q.promise} A promise that will throw an error or null if the group id was valid.\n * @private\n */\nfunction _setGroupIdOption(options, id) {\n    var errorPromise = null;\n\n    if (!_isGroupIdValid(id)) {\n        errorPromise = _errorPromise(\"The group id '\" + id + \"' is not valid for this Hue Bridge.\");\n    } else {\n        options.id = id;\n    }\n\n    return errorPromise;\n}\n\n/**\n * Validates and then injects the 'id' into the options for a group in the bridge.\n *\n * @param options The options to add the 'id' to.\n * @param id The id of the group\n * @return {Q.promise} A promise that will throw an error or null if the group id was valid.\n * @private\n */\nfunction _setGroupIdOptionForModification(options, id) {\n    var errorPromise = null;\n\n    if (!_isGroupIdValidForModification(id)) {\n        errorPromise = _errorPromise(\"The group id '\" + id + \"' cannot be modified on this Hue Bridge.\");\n    } else {\n        options.id = id;\n    }\n\n    return errorPromise;\n}\n\n/**\n * Validates and then injects the 'id' into the options for a group in the bridge.\n *\n * @param options The options to add the 'id' to.\n * @param id The id of the schedule\n * @return {Q.promise} A promise that will throw an error or null if the schedule id was valid.\n * @private\n */\nfunction _setScheduleIdOption(options, id) {\n    var errorPromise = null;\n\n    if (!_isScheduleIdValid(id)) {\n        errorPromise = _errorPromise(\"The schedule id '\" + id + \"' is not valid for this Hue Bridge.\");\n    } else {\n        options.id = id;\n    }\n\n    return errorPromise;\n}\n\n/**\n * Validates and then injects the schedule into the 'values' of the options.\n *\n * @param options The options to inject into.\n * @param schedule The schedule object containing the details for the schedule to create.\n * @returns {Q.promise} A promise containing any errors that might have occured, or <null> if there were none.\n * @private\n */\nfunction _setScheduleOptionsForCreation(options, schedule) {\n    var errorPromise = null;\n\n    // Use the API specification to check all required values have been provided.\n    Object.keys(schedulesApi.createSchedule.bodyArguments).forEach(function (value) {\n        var option = schedulesApi.createSchedule.bodyArguments[value];\n        if (!option.optional) {\n            // Check that the value has been provided\n            if (!errorPromise && !schedule[value]) {\n                errorPromise = _errorPromise(\"A required schedule option '\" + value + \"' was not provided.\");\n            }\n        }\n    });\n\n    if (!errorPromise) {\n        options.values = scheduledEvent.create(schedule);\n    }\n\n    return errorPromise;\n}\n\n/**\n * Validates and then injects the schedule into the 'values' of the options.\n *\n * @param options The options to inject into.\n * @param schedule The schedule object with the details of the updates to make.\n * @returns {Q.promise} A promise with any errors, if there were any, otherwise <null>.\n * @private\n */\nfunction _setScheduleOptionsForUpdate(options, schedule) {\n    var errorPromise = null,\n        validOptionFound = false;\n\n    // Use the API specification to check all the required values have been provided, or we have at least one value\n    Object.keys(schedulesApi.setScheduleAttributes.bodyArguments).forEach(function (value) {\n        if (schedule[value]) {\n            validOptionFound = true;\n        }\n    });\n\n    if (!validOptionFound) {\n        errorPromise = _errorPromise(\"No valid values for updating the schedule were found in the schedule details provided.\");\n    } else {\n        options.values = scheduledEvent.create(schedule);\n    }\n\n    return errorPromise;\n}\n\n/**\n * Validates and then injects the 'id' into the options for a group in the bridge.\n *\n * @param options The options to add the 'id' to.\n * @param sceneId The id of the scene\n * @return {Q.promise} A promise that will throw an error or null if the scene id was valid.\n * @private\n */\nfunction _setSceneIdOption(options, sceneId) {\n    var errorPromise = null;\n\n    if (!_isSceneIdValid(sceneId)) {\n        errorPromise = _errorPromise(\"The scene id '\" + sceneId + \"' is not valid for this Hue Bridge.\");\n    } else {\n        options.id = sceneId;\n    }\n\n    return errorPromise;\n}\n\n/**\n * Creates a promise that will generate an ApiError with the provided message.\n *\n * @param message The error message\n * @returns {Q.promise}\n * @private\n */\nfunction _errorPromise(message) {\n    var deferred = Q.defer();\n    deferred.reject(new ApiError(message));\n    return deferred.promise;\n}\n\n/**\n * Validates that the light id is valid for this Hue Bridge.\n *\n * @param id The id of the light in the Hue Bridge.\n * @returns {boolean} true if the id is valid for this bridge.\n * @private\n */\nfunction _isLightIdValid(id) {\n    if (parseInt(id, 10) > 0) {\n        //TODO check that this is a valid light id for the system\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Validates that the group id is valid for this Hue Bridge.\n *\n * @param id The id of the group in the Hue Bridge.\n * @returns {boolean} true if the id is valid for this bridge.\n * @private\n */\nfunction _isGroupIdValid(id) {\n    if (parseInt(id, 10) >= 0) {\n        //TODO check that this is a valid group id for the system\n        return id <= 16;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Validates that the group id is valid for modification on this Hue Bridge.\n *\n * @param id The id of the group in the Hue Bridge.\n * @returns {boolean} true if the id is valid for this bridge.\n * @private\n */\nfunction _isGroupIdValidForModification(id) {\n    if (_isGroupIdValid(id)) {\n        return parseInt(id, 10) > 0;\n    }\n    return false;\n}\n\n/**\n * Validates that the schedule id is valid for this Hue Bridge.\n *\n * @param id The id of the group in the Hue Bridge.\n * @returns {boolean} true if the id is valid for this bridge.\n * @private\n */\nfunction _isScheduleIdValid(id) {\n    if (parseInt(id, 10) >= 0) {\n        //TODO check that this is a valid schedule id for the system\n        return id <= 100;\n    } else {\n        return false;\n    }\n}\n\nfunction _isSceneIdValid(id) {\n    return id && (String(id).length > 0);\n}","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/lights-api.js":"\"use strict\";\n\n//\n// The Documented Phillips Hue Bridge API for lights http://developers.meethue.com/1_lightsapi.html\n//\n// This module wraps up all the functionality for the definition and basic processing of the parameters for the API\n// so that it can be called from the httpPromise module.\n//\n// The benefits of keeping all this code here is that it is much simpler to update the keep in step with the Phillips\n// Hue API documentation, than having it scatter piece meal through various other classes and functions.\n//\n\nvar Trait = require(\"traits\").Trait\n    , deepExtend = require(\"deep-extend\")\n    , tApiMethod = require(\"./traits/tApiMethod\")\n    , tDescription = require(\"./traits/tDescription\")\n    , tBodyArguments = require(\"./traits/tBodyArguments\")\n    , tLightStateBody = require(\"./traits/tLightStateBody\")\n    , tPostProcessing = require(\"./traits/tPostProcessing\")\n    , ApiError = require(\"../errors\").ApiError\n    , utils = require(\"../utils\")\n    ;\n\nvar apiTraits = {};\n\n\n//TODO tie this into the API definition as a post processing step, then apply it via the http.invoke()\nfunction buildLightsResult(result) {\n    var lights = [];\n\n    if (result) {\n        Object.keys(result).forEach(function (id) {\n            lights.push(deepExtend({id: id}, result[id]));\n        });\n    }\n    return {\"lights\": lights};\n}\n\nfunction processSetLightStateResult(result) {\n    if (!utils.wasSuccessful(result)) {\n        throw new ApiError(utils.parseErrors(result).join(\", \"));\n    }\n    return true;\n}\n\napiTraits.getAllLights = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/lights\",\n        \"GET\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Gets a list of all lights that have been discovered by the bridge.\"),\n    tPostProcessing(buildLightsResult)\n);\n\napiTraits.getNewLights = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/lights/new\",\n        \"GET\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Gets a list of lights that were discovered the last time a search for new lights was performed. \" +\n    \"The list of new lights is always deleted when a new search is started.\")\n);\n\napiTraits.searchForNewLights = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/lights\",\n        \"POST\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Starts a search for new lights. The bridge will search for 1 minute and will add a maximum of 15 new lights.\" +\n    \"To add further lights, the command needs to be sent again after the search has completed.\" +\n    \"If a search is already active, it will be aborted and a new search will start.\" +\n    \"When the search has finished, new lights will be available using the get new lights command.\" +\n    \"In addition, the new lights will now be available by calling get all lights or by calling get group \" +\n    \"attributes on group 0. Group 0 is a special group that cannot be deleted and will always contain all \" +\n    \"lights known by the bridge.\"),\n    tPostProcessing(utils.wasSuccessful)\n);\n\napiTraits.getLightAttributesAndState = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/lights/<id>\",\n        \"GET\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Gets the attributes and state of a given light.\")\n);\n\napiTraits.setLightAttributes = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/lights/<id>\",\n        \"PUT\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Used to rename lights. A light can have its name changed when in any state, including when it is unreachable or off.\"),\n    tBodyArguments(\n        \"application/json\",\n        [\n            {name: \"name\", type: \"string\", maxLength: 32, optional: false}\n        ]\n    ),\n    tPostProcessing(utils.wasSuccessful)\n);\n\napiTraits.setLightState = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/lights/<id>/state\",\n        \"PUT\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Allows the user to turn the light on and off, modify the hue and effects.\"),\n    tLightStateBody(true),\n    tPostProcessing(processSetLightStateResult)\n);\n\nmodule.exports = {\n    \"getAllLights\": Trait.create(Object.prototype, apiTraits.getAllLights),\n    \"getNewLights\": Trait.create(Object.prototype, apiTraits.getNewLights),\n    \"searchForNewLights\": Trait.create(Object.prototype, apiTraits.searchForNewLights),\n    \"getLightAttributesAndState\": Trait.create(Object.prototype, apiTraits.getLightAttributesAndState),\n    \"renameLight\": Trait.create(Object.prototype, apiTraits.setLightAttributes),\n    \"setLightState\": Trait.create(Object.prototype, apiTraits.setLightState)\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/traits/tBodyArguments.js":"\"use strict\";\n\nvar Trait = require(\"traits\").Trait;\n\nfunction createBodyArgumentTrait(options) {\n    var traitProperties = {\n        name: options.name,\n        type: options.type,\n        optional: options.optional\n    };\n\n    //TODO add more validation\n\n    if (options.type === \"string\") {\n        if (options.validValues) {\n            traitProperties.validValues = options.validValues;\n        }\n\n        if (options.maxLength) {\n            traitProperties.maxLength = options.maxLength;\n        }\n\n        if (options.minLength) {\n            traitProperties.minLength = options.minLength;\n        }\n    }\n\n    if (options.type === \"list\") {\n        if (options.listType) {\n            traitProperties.valueType = Trait.create(Object.prototype, createBodyArgumentTrait(options.listType));\n        }\n    }\n\n    if (options.defaultValue) {\n        traitProperties.defaultValue = options.defaultValue;\n    }\n\n    if (options.minValue !== undefined && options.maxValue !== undefined) {\n        traitProperties.range = {\"min\": options.minValue, \"max\": options.maxValue};\n    }\n\n    return Trait(traitProperties);\n}\n\n/**\n *\n * @param type the encoding type of the options, i.e. application/json\n * @param optionsArray The array of body options.\n * @returns {*}\n */\nmodule.exports = function (type, optionsArray) {\n    var options = {};\n\n    optionsArray.forEach(function (opt) {\n        options[opt.name] = Trait.create(Object.prototype, createBodyArgumentTrait(opt));\n    });\n\n    return Trait(\n        {\n            bodyType: type,\n            bodyArguments: options,\n\n            buildRequestBody: function (values) {\n                var body = {},\n                    self = this;\n\n                Object.keys(self.bodyArguments).forEach(function (argName) {\n                    var value = values ? values[argName] : undefined, // default to undefined if not set\n                        arg = self.bodyArguments[argName];\n\n                    if (self.bodyArguments.hasOwnProperty(argName)) {\n                        if (arg.optional) {\n                            body[argName] = value;\n                        } else {\n                            // We must have a value provided\n                            if (!value) {\n                                throw new Error(\"The required argument '\" + argName + \"' is missing a value\");\n                            }\n                            body[argName] = value;\n                        }\n                        //TODO add checking on the ranges/limits etc...\n                    }\n                });\n\n                return body;\n            }\n        }\n    );\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/traits/tLightStateBody.js":"\"use strict\";\n\nvar Trait = require(\"traits\").Trait,\n    tBodyArguments = require(\"./tBodyArguments\");\n\nmodule.exports = function (withAlert, withScene) {\n    var values = [\n        {\n            name: \"on\",\n            type: \"bool\",\n            optional: true\n        },\n\n        {\n            name: \"bri\",\n            type: \"uint8\",\n            minValue: 0,\n            maxValue: 254,\n            optional: true\n        },\n\n        {\n            name: \"hue\",\n            type: \"uint16\",\n            minValue: 0,\n            maxValue: 65535,\n            optional: true\n        },\n\n        {\n            name: \"sat\",\n            type: \"uint8\",\n            minValue: 0,\n            maxValue: 255,\n            optional: true\n        },\n\n        {\n            name: \"xy\",\n            type: \"list\",\n            listType: {\n                name: \"xyValue\",\n                type: \"float\",\n                minValue: 0,\n                maxValue: 1,\n                optional: false\n            },\n            optional: true\n        },\n\n        {\n            name: \"ct\",\n            type: \"uint8\",\n            minValue: 153,\n            maxValue: 500,\n            optional: true\n        },\n\n        {\n            name: \"effect\",\n            type: \"string\",\n            defaultValue: \"none\",\n            validValues: [\"none\", \"colorloop\"],\n            optional: true\n        },\n\n        {\n            name: \"transitiontime\",\n            type: \"uint16\",\n            defaultValue: 4,\n            minValue: 0,\n            maxValue: 65535,\n            optional: true\n        },\n\n        {\n            name: \"bri_inc\",\n            type: \"int8\",\n            minValue: -254,\n            maxValue: 254,\n            optional: true\n        },\n\n        {\n            name: \"sat_inc\",\n            type: \"int8\",\n            minValue: -254,\n            maxValue: 254,\n            optional: true\n        },\n\n        {\n            name: \"hue_inc\",\n            type: \"int16\",\n            minValue: -65534,\n            maxValue: 65534,\n            optional: true\n        },\n\n        {\n            name: \"ct_inc\",\n            type: \"int16\",\n            minValue: -65534,\n            maxValue: 65534,\n            optional: true\n        },\n\n        {\n            name: \"xy_inc\",\n            type: \"float\",\n            minValue: -0.5,\n            maxValue: 0.5,\n            optional: true\n        }\n    ];\n\n    if (withAlert) {\n        values.push({\n            name: \"alert\",\n            type: \"string\",\n            defaultValue: \"none\",\n            validValues: [\"none\", \"select\", \"lselect\"],\n            optional: true\n        });\n    }\n\n    if (withScene) {\n        values.push({\n            name: \"scene\",\n            type: \"string\",\n            optional: true\n        });\n    }\n\n    return tBodyArguments(\"application/json\", values);\n};\n","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/sensors-api.js":"\"use strict\";\n\n//\n// The Documented Phillips Hue Bridge API for lights http://developers.meethue.com/1_lightsapi.html\n//\n// This module wraps up all the functionality for the definition and basic processing of the parameters for the API\n// so that it can be called from the httpPromise module.\n//\n// The benefits of keeping all this code here is that it is much simpler to update the keep in step with the Phillips\n// Hue API documentation, than having it scatter piece meal through various other classes and functions.\n//\n\nvar Trait = require(\"traits\").Trait\n    , deepExtend = require(\"deep-extend\")\n    , tApiMethod = require(\"./traits/tApiMethod\")\n    , tDescription = require(\"./traits/tDescription\")\n    , tBodyArguments = require(\"./traits/tBodyArguments\")\n    , tLightStateBody = require(\"./traits/tLightStateBody\")\n    , tPostProcessing = require(\"./traits/tPostProcessing\")\n    , utils = require(\"../utils\")\n    ;\n\nvar apiTraits = {};\n\n//TODO tie this into the API definition as a post processing step, then apply it via the http.invoke()\nfunction buildSensorsResult(result) {\n    var sensors = [];\n\n    if (result) {\n        Object.keys(result).forEach(function (id) {\n            sensors.push(deepExtend({id: id}, result[id]));\n        });\n    }\n    return {\"sensors\": sensors};\n}\n\napiTraits.getAllSensors = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/sensors\",\n        \"GET\",\n        \"1.3\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Gets a list of all sensors that have been discovered by the bridge.\"),\n    tPostProcessing(buildSensorsResult)\n);\n\n\n//TODO there are many more endpoints that need to be added to this: http://www.developers.meethue.com/documentation/sensors-api\n\nmodule.exports = {\n    \"getAllSensors\": Trait.create(Object.prototype, apiTraits.getAllSensors)\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/groups-api.js":"\"use strict\";\n\n//\n// The Documented Phillips Hue Bridge API for groups http://www.developers.meethue.com/documentation/groups-api\n//\n// This module wraps up all the functionality for the definition and basic processing of the parameters for the API\n// so that it can be called from the httpPromise module.\n//\n// The benefits of keeping all this code here is that it is much simpler to update the keep in step with the Phillips\n// Hue API documentation, than having it scatter piece meal through various other classes and functions.\n//\n\nvar Trait = require(\"traits\").Trait\n    , deepExtend = require(\"deep-extend\")\n    , tApiMethod = require(\"./traits/tApiMethod\")\n    , tDescription = require(\"./traits/tDescription\")\n    , tBodyArguments = require(\"./traits/tBodyArguments\")\n    , tLightStateBody = require(\"./traits/tLightStateBody\")\n    , tPostProcessing = require(\"./traits/tPostProcessing\")\n    , tErrorHandling = require(\"./traits/tErrorHandling\")\n    , ApiError = require(\"../errors\").ApiError\n    , utils = require(\"../utils\")\n    ;\n\nvar ALL_LIGHTS_NAME = \"Lightset 0\"\n    , apiTraits = {}\n    ;\n\n/**\n * Parses the results from the All Groups request into a more useful format.\n * @param result The result from the Hue Bridge.\n * @returns {Array} An array of groups {\"id\": {*}, name: {*}} known to the bridge.\n * @private\n */\nfunction processAllGroups(result) {\n    var groupArray = [];\n\n    // There is an implicit all lights group that is not returned in the results of the lookup, so explicitly add it\n    groupArray.push({id: \"0\", name: ALL_LIGHTS_NAME, type: \"LightGroup\"});\n\n    Object.keys(result).forEach(function (value) {\n        groupArray.push(deepExtend({id: value}, result[value]));\n    });\n    return groupArray;\n}\n\nfunction ensureSuccessful(result) {\n    if (!utils.wasSuccessful(result)) {\n        throw new ApiError(utils.parseErrors(result).join(\", \"));\n    }\n    return true;\n}\n\nfunction processCreateGroup(result) {\n    var idString;\n\n    ensureSuccessful(result);\n\n    idString = result[0].success.id;\n    idString = idString.substr(idString.lastIndexOf(\"/\") + 1);\n\n    return {id: idString};\n}\n\nfunction processSetLightStateResult(result) {\n    if (!utils.wasSuccessful(result)) {\n        throw new ApiError(utils.parseErrors(result).join(\", \"));\n    }\n    return true;\n}\n\napiTraits.getAllGroups = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/groups\",\n        \"GET\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Gets a list of all groups that have been added to the bridge. A group is a list of lights that can be created, modified and deleted by a user. The maximum numbers of groups is 16. N.B. For the first bridge firmware release, bridge software version 01003542 only, a limited number of these APIs are supported in the firmware so only control of groups/0 is supported.\"),\n    tPostProcessing(processAllGroups)\n);\n\napiTraits.getGroupAttributes = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/groups/<id>\",\n        \"GET\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Gets the name, light membership and last command for a given group.\")\n//    tPostProcessing(_processGroupResult) // Cannot use this as we need to inject the id we were called with\n);\n\napiTraits.setGroupAttributes = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/groups/<id>\",\n        \"PUT\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Allows the user to modify the name and light membership of a group.\"),\n    tBodyArguments(\n        \"application/json\",\n        [\n            {name: \"name\", type: \"string\", maxLength: 32, optional: true},\n            {name: \"lights\", type: \"list int\", optional: true}\n        ]\n    ),\n    tPostProcessing(ensureSuccessful)\n);\n\napiTraits.setGroupState = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/groups/<id>/action\",\n        \"PUT\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Modifies the state of all lights in a group\"),\n    tLightStateBody(true, true),\n    tPostProcessing(processSetLightStateResult)\n);\n\napiTraits.createGroup = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/groups\",\n        \"POST\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Creates a new group containing the lights specified and optional name. A new group \"\n    + \"is created in the bridge with the next available id. Note: For bridges < 1.4 lights must be on, otherwise \"\n    + \"they won't be saved in the group. For 1.4 there is no such restriction.\"),\n    tBodyArguments(\n        \"application/json\",\n        [\n            {name: \"name\", type: \"string\", maxLength: 32, optional: true},\n            {name: \"lights\", type: \"list int\", optional: false}\n        ]\n    ),\n    tPostProcessing(processCreateGroup)\n);\n\napiTraits.deleteGroup = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/groups/<id>\",\n        \"DELETE\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Deletes the specified group from the bridge.\"),\n    tPostProcessing(ensureSuccessful),\n    tErrorHandling({305: \"It is not allowed to update or delete group of this type\"})\n);\n\n\nmodule.exports = {\n    getAllGroups: Trait.create(Object.prototype, apiTraits.getAllGroups),\n    getGroupAttributes: Trait.create(Object.prototype, apiTraits.getGroupAttributes),\n    setGroupAttributes: Trait.create(Object.prototype, apiTraits.setGroupAttributes),\n    setGroupState: Trait.create(Object.prototype, apiTraits.setGroupState),\n    createGroup: Trait.create(Object.prototype, apiTraits.createGroup),\n    deleteGroup: Trait.create(Object.prototype, apiTraits.deleteGroup)\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/traits/tErrorHandling.js":"\"use strict\";\n\nvar util = require(\"util\")\n    , Trait = require(\"traits\").Trait\n    , ApiError = require(\"../../errors\").ApiError\n    ;\n\nmodule.exports = function (codeMap) {\n    if (!codeMap) {\n        throw new ApiError(\"A status code to error messages object must be provided\");\n    }\n\n    return Trait({\n        statusCodeMap: codeMap\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/schedules-api.js":"\"use strict\";\n\n//\n// The Documented Phillips Hue Bridge API for schedules http://developers.meethue.com/3_schedulesapi.html\n//\n// This module wraps up all the functionality for the definition and basic processing of the parameters for the API\n// so that it can be called from the httpPromise module.\n//\n// The benefits of keeping all this code here is that it is much simpler to update the keep in step with the Phillips\n// Hue API documentation, than having it scatter piece meal through various other classes and functions.\n//\n\nvar Trait = require(\"traits\").Trait,\n    deepExtend = require(\"deep-extend\"),\n    tApiMethod = require(\"./traits/tApiMethod\"),\n    tDescription = require(\"./traits/tDescription\"),\n    tScheduleBody = require(\"./traits/tScheduleBody\"),\n    tPostProcessing = require(\"./traits/tPostProcessing\"),\n    ApiError = require(\"../errors\").ApiError,\n    utils = require(\"../utils\"),\n    apiTraits = {};\n\nfunction processAllSchedules(result) {\n    var values = [];\n\n    Object.keys(result).forEach(function (value) {\n        values.push(deepExtend({id: value}, result[value]));\n    });\n\n    return values;\n}\n\nfunction processScheduleResult(result) {\n    if (!utils.wasSuccessful(result)) {\n        throw new ApiError(utils.parseErrors(result).join(\", \"));\n    }\n\n    return {id: result[0].success.id};\n}\n\nfunction processDeletion(result) {\n    if (!utils.wasSuccessful(result)) {\n        throw new ApiError(utils.parseErrors(result).join(\", \"));\n    }\n\n    return true;\n}\n\nfunction validateUpdateResults(result) {\n    var returnValue = {};\n\n    if (!utils.wasSuccessful(result)) {\n        throw new ApiError(utils.parseErrors(result).join(\", \"));\n    }\n\n    result.forEach(function (value) {\n        Object.keys(value.success).forEach(function (keyValue) {\n            // The time values being returned do not appear to be correct from the Bridge, it is almost like\n            // they are in a transition state when the function returns the value, as such time values are not\n            // going to be returned from this function for now.\n            //\n            // Name and description values appear to be correctly represented in the results, but commands are\n            // typically cut short to just \"Updated\" so to cater for this variability I am just going to return\n            // true for each value that was modified, and leave it up to the user to request the value it was\n            // set to by re-querying the schedule.\n            //\n            // I have to trust that the Hue Bridge API will have set the values correctly when it reports\n            // success otherwise they have some serious issues...\n            var data = keyValue.substr(keyValue.lastIndexOf(\"/\") + 1, keyValue.length);\n            returnValue[data] = true;\n        });\n    });\n    return returnValue;\n}\n\napiTraits.getAllSchedules = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/schedules\",\n        \"GET\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Gets a list of all schedules that have been added to the bridge.\"),\n    tPostProcessing(processAllSchedules)\n);\n\napiTraits.createSchedule = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/schedules\",\n        \"POST\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Allows the user to create new schedules. The bridge can store up to 100 schedules.\"),\n    tScheduleBody(false),\n    tPostProcessing(processScheduleResult)\n);\n\napiTraits.getSchedule = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/schedules/<id>\",\n        \"GET\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Allows the user to change attributes of a schedule.\")\n);\n\napiTraits.setScheduleAttributes = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/schedules/<id>\",\n        \"PUT\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Sets attributes for a schedule.\"),\n    tScheduleBody(true),\n    tPostProcessing(validateUpdateResults)\n);\n\napiTraits.deleteSchedule = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/schedules/<id>\",\n        \"DELETE\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Deletes a schedule from the bridge.\"),\n    tPostProcessing(processDeletion)\n);\n\n\nmodule.exports = {\n    \"getAllSchedules\": Trait.create(Object.prototype, apiTraits.getAllSchedules),\n    \"createSchedule\": Trait.create(Object.prototype, apiTraits.createSchedule),\n    \"getSchedule\": Trait.create(Object.prototype, apiTraits.getSchedule),\n    \"setScheduleAttributes\": Trait.create(Object.prototype, apiTraits.setScheduleAttributes),\n    \"deleteSchedule\": Trait.create(Object.prototype, apiTraits.deleteSchedule)\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/traits/tScheduleBody.js":"\"use strict\";\n\nvar tBodyArguments = require(\"./tBodyArguments\");\n\nmodule.exports = function (allOptional) {\n    return tBodyArguments(\n        \"application/json\",\n        [\n            {name: \"name\", type: \"string\", maxLength: 32, optional: true},\n            {name: \"description\", type: \"string\", maxLength: 64, optional: true},\n            {name: \"command\", type: \"string\", maxLength: 90, optional: allOptional ? true : false},\n            {name: \"localtime\", type: \"time\", optional: allOptional ? true : false},\n            {name: \"status\", type: \"string\", minLength: 5, maxlength: 16, optional: true},\n            {name: \"autodelete\", type: \"boolean\", optional: true}\n        ]\n    );\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/scenes-api.js":"\"use strict\";\n\n//\n// The Documented Phillips Hue Bridge API for scenes http://www.developers.meethue.com/documentation/scenes-api\n//\n// This module wraps up all the functionality for the definition and basic processing of the parameters for the API\n// so that it can be called from the httpPromise module.\n//\n// The benefits of keeping all this code here is that it is much simpler to update the keep in step with the Phillips\n// Hue API documentation, than having it scatter piece meal through various other classes and functions.\n//\n\nvar Trait = require(\"traits\").Trait\n  , tApiMethod = require(\"./traits/tApiMethod\")\n  , tDescription = require(\"./traits/tDescription\")\n  , tPostProcessing = require(\"./traits/tPostProcessing\")\n  , tLightStateBody = require(\"./traits/tLightStateBody\")\n  , tBodyArguments = require(\"./traits/tBodyArguments\")\n  , ApiError = require(\"../errors\").ApiError\n  , utils = require(\"../utils\")\n  , apiTraits = {}\n  ;\n\nfunction processSceneResult(result) {\n  var response = {}\n    ;\n\n  if (!utils.wasSuccessful(result)) {\n    throw new ApiError(utils.parseErrors(result).join(\", \"));\n  }\n\n  function processResultObject(resultEntry) {\n    var obj = resultEntry.success\n      , idMatch = null\n      ;\n\n    Object.keys(obj).forEach(function (key) {\n      var id = key.substr(key.lastIndexOf(\"/\") + 1);\n      response[id] = obj[key];\n\n      if (!idMatch) {\n        idMatch = /scenes\\/(.*)\\//.exec(key);\n      }\n    });\n\n    if (!response.id && idMatch) {\n      response.id = idMatch[1];\n    }\n  }\n\n  if (Array.isArray(result)) {\n    result.forEach(processResultObject);\n  } else {\n    processResultObject(result);\n  }\n\n  return response;\n}\n\nfunction validateUpdateResults(result) {\n  var returnValue = {};\n\n  if (!utils.wasSuccessful(result)) {\n    throw new ApiError(utils.parseErrors(result).join(\", \"));\n  }\n\n  result.forEach(function (value) {\n    Object.keys(value.success).forEach(function (keyValue) {\n      var data = keyValue.substr(keyValue.lastIndexOf(\"/\") + 1, keyValue.length);\n      returnValue[data] = true;\n    });\n  });\n  return returnValue;\n}\n\napiTraits.getAllScenes = Trait.compose(\n  tApiMethod(\n    \"/api/<username>/scenes\",\n    \"GET\",\n    \"1.1\",\n    \"Whitelist\"\n  ),\n  tDescription(\"Gets a list of all scenes currently stored in the bridge. Scenes are represented by a scene id, a name and a list of lights which are part of the scene.\")\n);\n\napiTraits.createScene = Trait.compose(\n  tApiMethod(\n    \"/api/<username>/scenes\",\n    \"POST\",\n    \"1.11\",\n    \"Whitelist\"\n  ),\n  tDescription(\"Creates the given scene with all lights in the provided lights resource. For a given scene the current light settings of the given lights resources are stored. If the scene id is recalled in the future, these light settings will be reproduced on these lamps. If an existing name is used then the settings for this scene will be overwritten and the light states resaved.\"),\n  tBodyArguments(\n    \"application/json\",\n    [\n      {name: \"name\", type: \"string\", optional: true},\n      {name: \"lights\", type: \"list int\", optional: false},\n      {name: \"transitiontime\", type: \"int\", optional: true},\n      {name: \"recycle\", type: \"boolean\", optional: true},\n      {name: \"appdata\", type: \"object\", optional: true},\n      {name: \"picture\", type: \"hex\", optional: true}\n    ]\n  ),\n  tPostProcessing(processSceneResult)\n);\n\napiTraits.getScene = Trait.compose(\n  tApiMethod(\n    \"/api/<username>/scenes/<id>\",\n    \"GET\",\n    \"1.11\",\n    \"Whitelist\"\n  ),\n  tDescription(\"Gets the attributes of a given scene. Note that lightstates are displayed when an individual scene is retrieved (but not for all scenes).\")\n);\n\napiTraits.deleteScene = Trait.compose(\n  tApiMethod(\n    \"/api/<username>/scenes/<id>\",\n    \"DELETE\",\n    \"1.11\",\n    \"Whitelist\"\n  ),\n  tDescription(\"Deletes a scene from the bridge. In bridge versions earlier than 1.11 scenes cannot be deleted from the bridge.\")\n);\n\napiTraits.modifyLightState = Trait.compose(\n  tApiMethod(\n    \"/api/<username>/scenes/<id>/lightstates/<lightId>\",\n    \"PUT\",\n    \"1.11\",\n    \"Whitelist\"\n  ),\n  tDescription(\"Modifies or creates a new scene. Note that these states are not visible via any API calls, but stored in the lights themselves.\"),\n  tLightStateBody(),\n  tPostProcessing(validateUpdateResults)\n);\n\n//TODO this is deprecated in 1.11.x\napiTraits.oldModifyLightState = Trait.compose(\n  tApiMethod(\n    \"/api/<username>/scenes/<id>/lights/<lightId>/state\",\n    \"PUT\",\n    \"1.1.1\",\n    \"Whitelist\"\n  ),\n  tDescription(\"Modifies or creates a new scene. Note that these states are not visible via any API calls, but stored in the lights themselves.\"),\n  tLightStateBody(),\n  tPostProcessing(validateUpdateResults)\n);\n\napiTraits.modifyScene = Trait.compose(\n  tApiMethod(\n    \"/api/<username>/scenes/<id>\",\n    \"PUT\",\n    \"1.1.0\",\n    \"Whitelist\"\n  ),\n  tDescription(\"Modifies or creates a new scene. Note that these states are not visible via any API calls, but stored in the lights themselves.\"),\n  tBodyArguments(\n    \"application/json\",\n    [\n      {name: \"name\", type: \"string\", optional: true},\n      {name: \"lights\", type: \"list int\", optional: true},\n      {name: \"storelightstate\", type: \"boolean\", optional: true}\n    ]\n  ),\n  tPostProcessing(validateUpdateResults)\n);\n\nmodule.exports = {\n  getAllScenes: Trait.create(Object.prototype, apiTraits.getAllScenes),\n  createScene: Trait.create(Object.prototype, apiTraits.createScene),\n  modifyLightState: Trait.create(Object.prototype, apiTraits.modifyLightState),\n  modifyScene: Trait.create(Object.prototype, apiTraits.modifyScene),\n  getScene: Trait.create(Object.prototype, apiTraits.getScene),\n  deleteScene: Trait.create(Object.prototype, apiTraits.deleteScene)\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/configuration-api.js":"\"use strict\";\n\n//\n// The Documented Phillips Hue Bridge API for configuration http://developers.meethue.com/4_configurationapi.html\n//\n// This module wraps up all the functionality for the definition and basic processing of the parameters for the API\n// so that it can be called from the httpPromise module.\n//\n// The benefits of keeping all this code here is that it is much simpler to update the keep in step with the Phillips\n// Hue API documentation, than having it scatter piece meal through various other classes and functions.\n//\n\nvar Trait = require(\"traits\").Trait,\n    tApiMethod = require(\"./traits/tApiMethod\"),\n    tDescription = require(\"./traits/tDescription\"),\n    tBodyArguments = require(\"./traits/tBodyArguments\"),\n    tPostProcessing = require(\"./traits/tPostProcessing\"),\n    ApiError = require(\"../errors\").ApiError,\n    utils = require(\"../utils\"),\n    apiTraits = {};\n\n\nfunction processUserCreation(result) {\n    return result[0].success.username;\n}\n\nfunction processDeletionResults(result) {\n    if (!utils.wasSuccessful(result)) {\n        throw new ApiError(utils.parseErrors(result).join(\", \"));\n    }\n    return true;\n}\n\nfunction processModificationResults(result) {\n    if (!utils.wasSuccessful(result)) {\n        throw new ApiError(utils.parseErrors(result).join(\", \"));\n    }\n    return true;\n}\n\napiTraits.createUser = Trait.compose(\n    tApiMethod(\n        \"/api\",\n        \"POST\",\n        \"1.0\",\n        \"All\"\n    ),\n    tDescription(\"Creates a new user. The link button on the bridge must be pressed and this command executed within 30 seconds.\"),\n    tBodyArguments(\n        \"application/json\",\n        [\n            {name: \"devicetype\", type: \"string\", maxLength: 40, optional: false}\n        ]\n    ),\n    tPostProcessing(processUserCreation)\n);\n\napiTraits.getConfiguration = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/config\",\n        \"GET\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Returns list of all configuration elements in the bridge. Note all times are stored in UTC.\")\n);\n\napiTraits.modifyConfiguration = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/config\",\n        \"PUT\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Allows the user to set some configuration values.\"),\n    tBodyArguments(\n        \"application/json\",\n        [\n            {name: \"proxyport\", type: \"uint16\", optional: true},\n            {name: \"name\", type: \"string\", minLength: 4, maxLength: 16, optional: true},\n            {name: \"swupdate\", type: \"object\", optional: true},\n            {name: \"proxyaddress\", type: \"string\", maxLength: 40, optional: true},\n            {name: \"linkbutton\", type: \"boolean\", optional: true},\n            {name: \"ipaddress\", type: \"string\", optional: true},\n            {name: \"netmask\", type: \"string\", optional: true},\n            {name: \"gateway\", type: \"string\", optional: true},\n            {name: \"dhcp\", type: \"boolean\", optional: true},\n            {name: \"portalservices\", type: \"boolean\", optional: true}\n        ]\n    ),\n    tPostProcessing(processModificationResults)\n);\n\napiTraits.deleteUser = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/config/whitelist/<username2>\",\n        \"DELETE\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Deletes the specified user <username2>, from the whitelist.\"),\n    tPostProcessing(processDeletionResults)\n);\n\napiTraits.getFullState = Trait.compose(\n    tApiMethod(\n        \"/api/<username>\",\n        \"GET\",\n        \"1.0\",\n        \"Whitelist\"\n    ),\n    tDescription(\"This command is used to fetch the entire datastore from the device, including settings and state \" +\n    \"information for lights, groups, schedules and configuration. It should only be used sparingly as \" +\n    \"it is resource intensive for the bridge, but is supplied e.g. for synchronization purposes.\")\n);\n\nmodule.exports = {\n    \"createUser\": Trait.create(Object.prototype, apiTraits.createUser),\n    \"getConfiguration\": Trait.create(Object.prototype, apiTraits.getConfiguration),\n    \"getFullState\": Trait.create(Object.prototype, apiTraits.getFullState),\n    \"modifyConfiguration\": Trait.create(Object.prototype, apiTraits.modifyConfiguration),\n    \"deleteUser\": Trait.create(Object.prototype, apiTraits.deleteUser)\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/commands/info-api.js":"\"use strict\";\n\n//\n// The Documented Phillips Hue Bridge API for groups http://www.developers.meethue.com/documentation/info-api\n//\n// This module wraps up all the functionality for the definition and basic processing of the parameters for the API\n// so that it can be called from the httpPromise module.\n//\n// The benefits of keeping all this code here is that it is much simpler to update the keep in step with the Phillips\n// Hue API documentation, than having it scatter piece meal through various other classes and functions.\n//\n\nvar Trait = require(\"traits\").Trait\n    , tApiMethod = require(\"./traits/tApiMethod\")\n    , tDescription = require(\"./traits/tDescription\")\n    ;\n\nvar apiTraits = {};\n\napiTraits.getAllTimezones = Trait.compose(\n    tApiMethod(\n        \"/api/<username>/info/timezones\",\n        \"GET\",\n        \"1.2.1\",\n        \"Whitelist\"\n    ),\n    tDescription(\"Allows the user to list all supported bridge timezones.\")\n);\n\nmodule.exports = {\n    getAllTimezones: Trait.create(Object.prototype, apiTraits.getAllTimezones)\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/scheduledEvent.js":"\"use strict\";\n\nvar util = require(\"util\")\n  , utils = require(\"./utils\")\n  , errors = require(\"./errors\")\n  ;\n\nvar patterns = {\n    time: \"\\\\d{2}:\\\\d{2}:\\\\d{2}\",\n    weekday: \"W[0-9]{1,3}\",\n    date: \"\\\\d{4}-\\\\d{2}-\\\\d{2}\"\n  },\n  regularExpressions = {\n    absolute: new RegExp(util.format(\"%sT%s\", patterns.date, patterns.time)),\n    randomized: new RegExp(util.format(\"%sT%sA%s\", patterns.date, patterns.time, patterns.time)),\n    recurring: new RegExp(util.format(\"%s\\/T%s\", patterns.weekday, patterns.time)),\n    recurringRandomized: new RegExp(util.format(\"%s\\/T%sA%s\", patterns.weekday, patterns.time, patterns.time)),\n    timer: new RegExp(util.format(\"PT%s\", patterns.time)),\n    timerRandom: new RegExp(util.format(\"PT%sA%s\", patterns.time, patterns.time)),\n    timerRecurringCount: new RegExp(util.format(\"R\\\\d{2}\\/PT%s\", patterns.time)),\n    timerRecurring: new RegExp(util.format(\"R\\/PT%s\", patterns.time)),\n    timerRecurringCountRandom: new RegExp(util.format(\"R\\\\d{2}\\/PT%sA%s\", patterns.time, patterns.time))\n  };\n\nvar Schedule = function () {\n};\n\nmodule.exports.create = function () {\n  var schedule,\n    arg;\n\n  if (arguments.length == 0) {\n    schedule = new Schedule();\n  } else {\n    arg = arguments[0];\n    if (arg instanceof Schedule) {\n      schedule = arg;\n    } else {\n      schedule = new Schedule();\n\n      // try to populate the new schedule using any values that match schedule properties\n      if (arg.name) {\n        schedule.withName(arg.name);\n      }\n\n      if (arg.description) {\n        schedule.withDescription(arg.description);\n      }\n\n      if (arg.time || arg.localtime) {\n        schedule.at(arg.time || arg.localtime);\n      }\n\n      if (arg.command) {\n        schedule.withCommand(arg.command);\n      }\n\n      if (arg.status) {\n        schedule.withEnabledState(arg.status);\n      }\n    }\n  }\n\n  return schedule;\n};\n\nSchedule.prototype.at = function (time) {\n  utils.combine(this, _getTimeValue(time));\n  return this;\n};\n\nSchedule.prototype.on = function (time) {\n  utils.combine(this, _getTimeValue(time));\n  return this;\n};\n\nSchedule.prototype.when = function (time) {\n  utils.combine(this, _getTimeValue(time));\n  return this;\n};\n\nSchedule.prototype.atRandomizedTime = function(time) {\n  if (regularExpressions.randomized.test(time)) {\n    utils.combine(this, {localtime: time});\n  } else {\n    throw new errors.ApiError(util.format(\"Time '%s' is not correct for randomized time\", time));\n  }\n};\n\nSchedule.prototype.atRecurringTime = function (time) {\n  if (regularExpressions.recurring.test(time)) {\n    utils.combine(this, {localtime: time});\n  } else {\n    throw new errors.ApiError(util.format(\"Time '%s' is not correct for recurring time\", time));\n  }\n};\n\nSchedule.prototype.atRecurringRandomizedTime = function(time) {\n  if (regularExpressions.recurringRandomized.test(time)) {\n    utils.combine(this, {localtime: time});\n  } else {\n    throw new errors.ApiError(util.format(\"Time '%s' is not correct for recurring randomized time\", time));\n  }\n};\n\nSchedule.prototype.withName = function (name) {\n  // The 1.0 API only accepts up to 32 characters for the name\n  var nameCharMax = 32;\n\n  utils.combine(this, {\"name\": utils.getStringValue(name, nameCharMax)});\n  return this;\n};\n\nSchedule.prototype.withDescription = function (description) {\n  // The 1.0 API only accepts up to 64 characters for the description\n  utils.combine(this, {\"description\": utils.getStringValue(description, 64)});\n  return this;\n};\n\nSchedule.prototype.withCommand = function (command) {\n  var type = typeof(command),\n    commandObject = null;\n\n  // The command is limited to 90 characters, so if a string is passed, convert it to an object and back into JSON.\n\n  if (type === \"string\") {\n    commandObject = JSON.parse(command);\n  } else {\n    commandObject = command;\n  }\n\n  _validateCommand(commandObject);\n\n  utils.combine(this, {\"command\": commandObject});\n  return this;\n};\n\nSchedule.prototype.withEnabledState = function (enabled) {\n  var state;\n\n  if (enabled === \"enabled\") {\n    state = \"enabled\";\n  } else if (enabled === \"disabled\") {\n    state = \"disabled\";\n  } else {\n    state = enabled ? \"enabled\" : \"disabled\";\n  }\n\n  utils.combine(this, {status: state});\n};\n\nfunction _getTimeValue(time) {\n  var result = {}\n    , type = typeof time\n    , timeValue = null\n    ;\n\n  if (type === 'string') {\n    // Check the string against all known patterns\n    Object.keys(regularExpressions).forEach(function (regex) {\n      if (!timeValue && regularExpressions[regex].test(time)) {\n        timeValue = time;\n      }\n    });\n\n    if (!timeValue) {\n      // We don't have a match, but it may still be a valid time, so attempt to parse it\n      timeValue = _convertToDate(time);\n    }\n  } else if (type === 'number') {\n    timeValue = _convertNumberToHueTime(time);\n  } else if (type === 'object') {\n    if (time instanceof Date) {\n      timeValue = _convertNumberToHueTime(time.getTime())\n    }\n  }\n\n  if (timeValue === null) {\n    throw new errors.ApiError(\"Invalid time value, '\" + time + \"'\");\n  }\n\n  result.localtime = timeValue;\n  return result;\n}\n\nfunction _convertNumberToHueTime(number) {\n  var result = null;\n\n  if (!isNaN(number)) {\n    result = _convertDateToHueTime(new Date(number));\n  }\n  return result;\n}\n\nfunction _convertDateToHueTime(date) {\n  var result = null\n    , str\n    ;\n\n  if (date) {\n    str = date.toJSON();\n    result = str.substring(0, str.lastIndexOf(\".\"))\n  }\n\n  return result;\n}\n\nfunction _convertToDate(str) {\n  var result = null\n    , time = Date.parse(str)\n    ;\n\n  if (!isNaN(time)) {\n    result = _convertNumberToHueTime(time);\n  }\n\n  return result;\n}\n\n/**\n * Perform validation on a command object to verify it can be considered valid.\n * @param commandObject the object representing the command to be validated.\n * @throws {ApiError} if a problem is encountered with the command\n * @private\n */\nfunction _validateCommand(commandObject) {\n  var address,\n    method,\n    body;\n\n  if (commandObject) {\n    address = commandObject.address;\n    if (address) {\n      //TODO expand the regex to match proper end points valid for schedules\n      var addressPattern = /^\\/api\\/\\.*\\/\\.*/;\n      if (addressPattern.test(address)) {\n        throw new errors.ApiError(\"The 'address' property must begin with '/api' to be a valid endpoint\");\n      }\n    } else {\n      throw new errors.ApiError(\"The 'address' property must be specified.\");\n    }\n\n    //TODO link this with the valid endpoints in the address\n    method = commandObject.method;\n    if (!commandObject.method) {\n      throw new errors.ApiError(\"The 'method' must be specified.\");\n    }\n\n    body = commandObject.body;\n    if (!commandObject.body) {\n      throw new errors.ApiError(\"The 'body' property must be specified.\");\n    }\n  } else {\n    throw new errors.ApiError(\"Command is not defined\");\n  }\n}","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/lightstate.js":"\"use strict\";\n\nvar util = require(\"util\")\n    , utils = require(\"./utils\")\n    , rgb = require(\"./rgb\")\n    , lightStateTrait = require(\"./commands/traits/tLightStateBody\")\n    ;\n\nvar stateDefinitions = lightStateTrait(true).bodyArguments.value\n    , State = function () {\n        this.reset();\n    };\n\n/**\n * Creates a new state object to pass to a Philips Hue Light.\n *\n * @param values An optional object that contains state properties and values that are to be loaded into the created\n * state object. Any properties that are not 'valid' properties of the Light State are not loaded.\n *\n * @return {State}\n */\nmodule.exports.create = function (values) {\n    var state = new State();\n\n    // If values are provided then load the ones that have values to match our functions\n    if (values) {\n        Object.keys(values).forEach(function (value) {\n            var fn;\n\n            if (values.hasOwnProperty(value)) {\n                fn = state[value];\n\n                if (utils.isFunction(fn)) {\n                    fn.apply(state, [values[value]]);\n                }\n            }\n        });\n    }\n\n    return state;\n};\n\nmodule.exports.isLightState = function (obj) {\n    return obj && obj instanceof State;\n};\n\nState.prototype.payload = function () {\n    return JSON.parse(JSON.stringify(this._values));\n};\n\n/**\n * Resets/Clears the properties that have been set in the light state object.\n * @returns {State}\n */\nState.prototype.reset = function () {\n    this._values = {};\n    return this;\n};\nState.prototype.clear = State.prototype.reset;\n\n/**\n * Creates a copy of the state object\n * @returns {State}\n */\nState.prototype.copy = function () {\n    var copy = new State();\n    copy._addValues(this._values);\n    return copy;\n};\n\n/**\n * Sets the strict state for setting parameters for the light state.\n * @param strict\n * @returns {State}\n */\nState.prototype.strict = function (strict) {\n    this._strict = Boolean(strict);\n    return this;\n};\n\nState.prototype.isStrict = function () {\n    return this._strict;\n};\n\n/**\n * Sets the on state\n * @param on The state (true for on, false for off). If this parameter is not specified, it is assumed to be true.\n * @returns {State}\n */\nState.prototype.on = function (on) {\n    this._addValues(_getOnState(on));\n    return this;\n};\n\n/**\n * Adds the bri state\n * @param value The hue bri value, 0 to 254.\n * @return {State}\n */\nState.prototype.bri = function (value) {\n    this._addValues(_getBriState(value));\n    return this;\n};\n\n/**\n * Adds the hue for the color desired.\n * @param hue The hue value is a wrapping value between 0 and 65535. Both 0 and 65535 are red, 25500 is green and 46920 is blue.\n * @returns {State}\n */\nState.prototype.hue = function (hue) {\n    this._addValues(_getHueState(hue));\n    return this;\n};\n\n/**\n * The saturation of the color for the bulb, 0 being the least saturated i.e. white.\n * @param saturation The saturation value 0 to 255\n * @returns {State}\n */\nState.prototype.sat = function (saturation) {\n    this._addValues(_getSatState(saturation));\n    return this;\n};\n\n/**\n * Adds the xy values\n * @param x The x value ranged from 0 to 1, or an Array of [x, y] values\n * @param y The y value ranged from 0 to 1\n * @return {State}\n */\nState.prototype.xy = function (x, y) {\n    // Cater for the first argument being an array\n    if (Array.isArray(arguments[0])) {\n        x = arguments[0][0];\n        y = arguments[0][1];\n    }\n\n    this._addValues(_getXYState(x, y));\n    return this;\n};\n\n/**\n * Adds the Mired Color Temperature\n * @param colorTemp The Color Temperature between 153 to 500 inclusive.\n * @returns {State}\n */\nState.prototype.ct = function (colorTemp) {\n    this._addValues(_getCtState(colorTemp));\n    return this;\n};\n\n/**\n * Adds the alert state\n * @param value A String value representing the alert state, \"none\", \"select\", \"lselect\".\n * @return {State}\n */\nState.prototype.alert = function (value) {\n    this._addValues(_getAlertState(value));\n    return this;\n};\n\n/**\n * Adds an effect for the bulb.\n * @param value The type of effect, currently supports \"none\" and \"colorloop\".\n * @returns {State}\n */\nState.prototype.effect = function (value) {\n    this._addValues(_getEffectState(value));\n    return this;\n};\n\n/**\n * Adds a transition to the desired state.\n * @param value This is given as a multiple of 100ms and defaults to 4 (400ms).\n * @return {State}\n */\nState.prototype.transitiontime = function (value) {\n    this._addValues(_getTransitionState(value));\n    return this;\n};\n\n/**\n * Increments/Decrements the brightness value for the lights.\n * @param value An amount to change the current brightness by, -254 to 254.\n * @returns {State}\n */\nState.prototype.bri_inc = function (value) {\n    this._addValues(_getBrightnessIncrementState(value));\n    return this;\n};\n\n/**\n * Increments/Decrements the saturation value for the lights.\n * @param value An amount to change the current saturation by, -254 to 254.\n * @returns {State}\n */\nState.prototype.sat_inc = function (value) {\n    this._addValues(_getSaturationIncrementState(value));\n    return this;\n};\n\n/**\n * Increments/Decrements the Hue value for the lights.\n * @param value An amount to change the current hue by, -65534 to 65534.\n * @returns {State}\n */\nState.prototype.hue_inc = function (value) {\n    this._addValues(_getHueIncrementState(value));\n    return this;\n};\n\n/**\n * Increments/Decrements the color temperature value for the lights.\n * @param value An amount to change the current color temperature by, -65534 to 65534.\n * @returns {State}\n */\nState.prototype.ct_inc = function (value) {\n    this._addValues(_getCtIncrementState(value));\n    return this;\n};\n\n/**\n * Increments/Decrements the XY value for the lights.\n * @param value An amount to change the current XY by, -0.5 to 0.5.\n * @returns {State}\n */\nState.prototype.xy_inc = function (value) {\n    this._addValues(_getXYIncrementState(value));\n    return this;\n};\n\nState.prototype.scene = function (value) {\n    this._addValues(_getSceneId(value));\n    return this;\n};\n\n\n///////////////////////////////////////////////////////////////////////\n// Convenience functions\n\nState.prototype.turnOn = State.prototype.on;\n\nState.prototype.off = function () {\n    this._addValues(_getOnState(false));\n    return this;\n};\nState.prototype.turnOff = State.prototype.off;\n\n/**\n * Set the brightness as a percent value\n * @param percentage The brightness percentage value between 0 and 100.\n * @returns {State}\n */\nState.prototype.brightness = function (percentage) {\n    return this.bri(_convertBrightPercentToHueValue(percentage));\n};\n\nState.prototype.incrementBrightness = State.prototype.bri_inc;\n\nState.prototype.colorTemperature = State.prototype.ct;\nState.prototype.colourTemperature = State.prototype.ct;\nState.prototype.colorTemp = State.prototype.ct;\nState.prototype.colourTemp = State.prototype.ct;\n\nState.prototype.incrementColorTemp = State.prototype.ct_inc;\nState.prototype.incrementColorTemperature = State.prototype.ct_inc;\nState.prototype.incrementColourTemp = State.prototype.ct_inc;\nState.prototype.incrementColourTemperature = State.prototype.ct_inc;\n\nState.prototype.incrementHue = State.prototype.hue_inc;\n\nState.prototype.incrementXY = State.prototype.xy_inc;\n\nState.prototype.saturation = function (percentage) {\n    return this.sat(_convertSaturationPercentToHueValue(percentage));\n};\n\nState.prototype.incrementSaturation = State.prototype.sat_inc;\n\nState.prototype.shortAlert = function () {\n    return this.alert(\"select\");\n};\nState.prototype.alertShort = State.prototype.shortAlert;\n\nState.prototype.longAlert = function () {\n    return this.alert(\"lselect\");\n};\nState.prototype.alertLong = State.prototype.longAlert;\n\nState.prototype.transitionTime = State.prototype.transitiontime;\n/**\n * Sets the transition time in milliseconds.\n * @param milliseconds The number of milliseconds for the transition\n * @returns {State}\n */\nState.prototype.transition = function (milliseconds) {\n    return this.transitionTime(_convertMilliSecondsToTransitionTime(milliseconds));\n};\nState.prototype.transitiontime_milliseconds = State.prototype.transition;\nState.prototype.transitionTime_milliseconds = State.prototype.transition;\n\nState.prototype.transitionSlow = function () {\n    return this.transitionTime(8);\n};\n\nState.prototype.transitionFast = function () {\n    return this.transitionTime(2);\n};\n\nState.prototype.transitionInstant = function () {\n    return this.transitionTime(0);\n};\n\nState.prototype.transitionDefault = function () {\n    return this.transitionTime(4);//TODO should load this from the definition\n};\n\n/**\n * Builds the White state for a lamp\n * @param colorTemp The temperature, a value of 153-500\n * @param brightPercentage The percentage of brightness 0-100\n * @return {State}\n */\nState.prototype.white = function (colorTemp, brightPercentage) {\n    this._addValues(_getWhiteState(colorTemp, brightPercentage));\n    return this;\n};\n\n/**\n * Adds the HSL values\n * @param hue The hue value in degrees 0-360\n * @param saturation The saturation percentage 0-100\n * @param luminosity The luminosity percentage 0-100\n * @return {State}\n */\nState.prototype.hsl = function (hue, saturation, luminosity) {\n    var temp = saturation * (luminosity < 50 ? luminosity : 100 - luminosity) / 100\n        , satValue = Math.round(200 * temp / (luminosity + temp)) | 0\n        , luminosityValue = Math.round(temp + luminosity)\n        ;\n\n    return this\n        .brightness(luminosityValue)\n        .hue(_convertHueToHueValue(hue))\n        .sat(_convertSaturationPercentToHueValue(satValue))\n        ;\n};\n\n/**\n * Adds the HSB values\n * @param hue The hue value in degrees 0-360\n * @param saturation The saturation percentage 0-100\n * @param brightness The brightness percentage 0-100\n * @return {State}\n */\nState.prototype.hsb = function (hue, saturation, brightness) {\n    return this\n        .brightness(brightness)\n        .hue(_convertHueToHueValue(hue))\n        .sat(_convertSaturationPercentToHueValue(saturation))\n        ;\n};\n\n/**\n * Adds the rgb color to the state. This requires knowledge of the light type to be able to convert it into\n * an actual color that the map can display.\n *\n * @param r The amount of Red 0-255, or an {Array} or r, g, b values.\n * @param g The amount of Green 0-255\n * @param b The amount of Blue 0-255\n * @return {State}\n */\nState.prototype.rgb = function (r, g, b) {\n    // The conversion to rgb is now done in the xy space, but to do so requires knowledge of the limits of the light's\n    // color gamut.\n    // To cater for this, we store the rgb value requested, and convert it to xy when the user applies it.\n\n    // We may have an array passed in, cater for that\n    if (Array.isArray(arguments[0])) {\n        r = arguments[0][0];\n        g = arguments[0][1];\n        b = arguments[0][2];\n    }\n\n    this._addValues({\n        rgb: [\n            _getBoundedValue(r, 0, 255),\n            _getBoundedValue(g, 0, 255),\n            _getBoundedValue(b, 0, 255)\n        ]\n    });\n    return this;\n};\n\nState.prototype.hasRGB = function () {\n    return !!this._values.rgb;\n};\n\nState.prototype.colorLoop = function () {\n    return this.effect(\"colorloop\");\n};\nState.prototype.colourLoop = State.prototype.colorLoop;\nState.prototype.effectColorLoop = State.prototype.colorLoop;\nState.prototype.effectColourLoop = State.prototype.colorLoop;\n\n/**\n * Creates a copy of the State if there is an RGB value set.\n *\n * @param modelid The model ID of the light(s) to convert the rgb value for.\n *\n * @returns {State} If there is an RGB value set, then a copy of the state, with the rgb value applied based on the\n * lamp model provided. If there is no RGB value set, then {null} will be returned.\n */\nState.prototype.applyRGB = function (modelid) {\n    var result = null;\n\n    if (this.hasRGB()) {\n        result = this.copy();\n        result.xy(rgb.convertRGBtoXY(this._values.rgb, modelid));\n    }\n\n    return result;\n};\n\n///////////////////////////////////////////////////////////////////////\n\nState.prototype._addValues = function () {\n    var state = this._values;\n\n    Array.prototype.slice.apply(arguments).forEach(function (stateValue) {\n        utils.combine(state, stateValue);\n    });\n};\n\nState.prototype._removeValues = function () {\n    var state = this._values;\n\n    Array.prototype.slice.apply(arguments).forEach(function (key) {\n        delete state[key];\n    });\n};\n\n\n/////////////////////////////////\n// State objects\n\nfunction _getOnState(value) {\n    if (value == null || value === undefined) {\n        value = true;\n    }\n\n    return {\n        on: _getOnValue(value)\n    };\n}\n\nfunction _getBriState(value) {\n    return {\n        bri: _getBrightnessValue(value)\n    };\n}\n\nfunction _getHueState(value) {\n    return {\n        hue: _getHueValue(value)\n    };\n}\n\nfunction _getSatState(value) {\n    return {\n        sat: _getSaturationValue(value)\n    };\n}\n\nfunction _getXYState(x, y) {\n    return {\n        xy: _getXYValue(x, y)\n    };\n}\n\nfunction _getCtState(value) {\n    return {\n        ct: _getCtValue(value)\n    };\n}\n\nfunction _getAlertState(value) {\n    return {\n        alert: _getAlertValue(value)\n    };\n}\n\nfunction _getEffectState(value) {\n    return {\n        effect: _getEffectValue(value)\n    };\n}\n\nfunction _getTransitionState(value) {\n    return {\n        transitiontime: _getTransitionTimeValue(value)\n    };\n}\n\nfunction _getBrightnessIncrementState(value) {\n    return {\n        bri_inc: _getBrightnessIncrementValue(value)\n    }\n}\n\nfunction _getSaturationIncrementState(value) {\n    return {\n        sat_inc: _getSaturationIncrementValue(value)\n    }\n}\n\nfunction _getHueIncrementState(value) {\n    return {\n        hue_inc: _getHueIncrementValue(value)\n    }\n}\n\nfunction _getCtIncrementState(value) {\n    return {\n        ct_inc: _getCtIncrementValue(value)\n    }\n}\n\nfunction _getXYIncrementState(value) {\n    return {\n        xy_inc: _getXYIncrementValue(value)\n    }\n}\n\nfunction _getSceneId(value) {\n    var result = {};\n\n    if (value) {\n        result.scene = value;\n    }\n    return result;\n}\n\nfunction _getWhiteState(colorTemp, brightness) {\n    return utils.combine(\n        _getCtState(colorTemp),\n        _getBriState(_convertBrightPercentToHueValue(brightness))\n    );\n}\n\n/////////////////////////////////\n// Value Functions\n\nfunction _convertHueToHueValue(hue) {\n    return _getBoundedValue(hue, 0, 360) * 182.5487\n}\n\nfunction _convertMilliSecondsToTransitionTime(value) {\n    var result = 0;\n\n    // The transition time is in multiples of 100ms, e.g. 100ms = 1\n    if (value > 0) {\n        result = Math.round(value / 100);\n    }\n\n    return result;\n}\n\nfunction _getTransitionTimeValue(value) {\n    var transition = stateDefinitions.transitiontime;\n    return valueForType(transition, _getRangeValue(transition, value));\n}\n\nfunction _getBrightnessIncrementValue(value) {\n    var bri_inc = stateDefinitions.bri_inc;\n    return valueForType(bri_inc, _getRangeValue(bri_inc, value));\n}\n\nfunction _getSaturationIncrementValue(value) {\n    var sat_inc = stateDefinitions.sat_inc;\n    return valueForType(sat_inc, _getRangeValue(sat_inc, value));\n}\n\nfunction _getHueIncrementValue(value) {\n    var hue_inc = stateDefinitions.hue_inc;\n    return valueForType(hue_inc, _getRangeValue(hue_inc, value));\n}\n\nfunction _getCtIncrementValue(value) {\n    var ct_inc = stateDefinitions.ct_inc;\n    return valueForType(ct_inc, _getRangeValue(ct_inc, value));\n}\n\nfunction _getXYIncrementValue(value) {\n    var xy_inc = stateDefinitions.xy_inc;\n    return valueForType(xy_inc, _getRangeValue(xy_inc, value));\n}\n\nfunction convertPercentToValue(definition, percent) {\n    var range = definition.range\n        , min = range.min\n        , max = range.max\n        , normalizedValue = _getBoundedValue(percent, 0, 100)\n        ;\n\n    if (normalizedValue === 0) {\n        return min;\n    } else if (normalizedValue === 100) {\n        return max;\n    } else {\n        return normalizedValue * (max / 100);\n    }\n}\n\nfunction _convertSaturationPercentToHueValue(value) {\n    return _getSaturationValue(convertPercentToValue(stateDefinitions.sat, value));\n}\n\nfunction _convertBrightPercentToHueValue(value) {\n    return _getBrightnessValue(convertPercentToValue(stateDefinitions.bri, value));\n}\n\n/**\n * Obtains the XY color values that the Hue Lights can understand\n * @param x The X value\n * @param y The Y value\n * @return {Array} The converted xy values.\n */\nfunction _getXYValue(x, y) {\n    var xy = stateDefinitions.xy\n        , validateValueFn = function (value) {\n            var valueType = xy.valueType\n                , normalized = _getRangeValue(valueType, value)\n                ;\n            return valueForType(valueType, normalized);\n        }\n        ;\n\n    return valueForType(xy, [validateValueFn(x), validateValueFn(y)]);\n}\n\nfunction _getSaturationValue(value) {\n    var sat = stateDefinitions.sat;\n    return valueForType(sat, _getRangeValue(sat, value));\n}\n\nfunction _getHueValue(value) {\n    var hue = stateDefinitions.hue;\n    return valueForType(hue, _getRangeValue(hue, value));\n}\n\n/**\n * Color Temperature values are limited to the range of 153 - 500, cold to warm.\n * @param value The value to set as a {String} or {Integer}\n * @return {Number} The color temperature to use.\n */\nfunction _getCtValue(value) {\n    var ct = stateDefinitions.ct;\n    return valueForType(ct, _getRangeValue(ct, value));\n}\n\n/**\n * Brightness values are limited to the range of 0 - 254.\n * @param value The value to set as a {String} or {Integer}\n * @return {Number} The brightness value to use.\n */\nfunction _getBrightnessValue(value) {\n    var bri = stateDefinitions.bri;\n    return valueForType(bri, _getRangeValue(bri, value));\n}\n\nfunction _getAlertValue(value) {\n    var alert = stateDefinitions.alert;\n    return valueForType(alert, _getOptionValue(alert, value));\n}\n\nfunction _getOnValue(value) {\n    var on = stateDefinitions.on;\n    return valueForType(on, value);\n}\n\nfunction _getEffectValue(value) {\n    var effect = stateDefinitions.effect;\n    return valueForType(effect, _getOptionValue(effect, value));\n}\n\nfunction _getOptionValue(definition, value) {\n    var validValues = definition.validValues\n        , resolved\n        ;\n\n    validValues.forEach(function (validValue) {\n        if (!resolved && validValue === value) {\n            resolved = value;\n        }\n    });\n\n    return resolved || definition.defaultValue || validValues[0];\n}\n\nfunction _getRangeValue(definition, value) {\n    var range = definition.range;\n\n    if (value === undefined || value === null && definition.defaultValue) {\n        value = definition.defaultValue;\n    }\n\n    return _getBoundedValue(value, range.min, range.max)\n}\n\n/**\n * Obtains a value that falls within the specified range\n * @param value The value to check\n * @param min The minimum allowed value\n * @param max The maximum allowed value\n * @return {*} The value that sits within the specified range\n */\nfunction _getBoundedValue(value, min, max) {\n    if (isNaN(value)) {\n        value = min;\n    }\n\n    if (value < min) {\n        return min;\n    } else if (value > max) {\n        return max;\n    } else {\n        return value;\n    }\n}\n\nfunction valueForType(definition, value) {\n    return utils.valueForType(definition.type, value);\n}","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/rgb.js":"\"use strict\";\n\nvar XY = function (x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    , hueLimits = {\n        red: new XY(0.675, 0.322),\n        green: new XY(0.4091, 0.518),\n        blue: new XY(0.167, 0.04)\n    }\n    , livingColorsLimits = {\n        red: new XY(0.704, 0.296),\n        green: new XY(0.2151, 0.7106),\n        blue: new XY(0.138, 0.08)\n    }\n    , defaultLimits = {\n        red: new XY(1.0, 0),\n        green: new XY(0.0, 1.0),\n        blue: new XY(0.0, 0.0)\n    }\n    ;\n\nfunction _crossProduct(p1, p2) {\n    return (p1.x * p2.y - p1.y * p2.x);\n}\n\nfunction _isInColorGamut(p, lampLimits) {\n    var v1 = new XY(\n            lampLimits.green.x - lampLimits.red.x\n            , lampLimits.green.y - lampLimits.red.y\n        )\n        , v2 = new XY(\n            lampLimits.blue.x - lampLimits.red.x\n            , lampLimits.blue.y - lampLimits.red.y\n        )\n        , q = new XY(p.x - lampLimits.red.x, p.y - lampLimits.red.y)\n        , s = _crossProduct(q, v2) / _crossProduct(v1, v2)\n        , t = _crossProduct(v1, q) / _crossProduct(v1, v2)\n        ;\n\n    return (s >= 0.0) && (t >= 0.0) && (s + t <= 1.0);\n}\n\n/**\n * Find the closest point on a line. This point will be reproducible by the limits.\n *\n * @param start {XY} The point where the line starts.\n * @param stop {XY} The point where the line ends.\n * @param point {XY} The point which is close to the line.\n * @return {XY} A point that is on the line specified, and closest to the XY provided.\n */\nfunction _getClosestPoint(start, stop, point) {\n    var AP = new XY(point.x - start.x, point.y - start.y)\n        , AB = new XY(stop.x - start.x, stop.y - start.y)\n        , ab2 = AB.x * AB.x + AB.y * AB.y\n        , ap_ab = AP.x * AB.x + AP.y * AB.y\n        , t = ap_ab / ab2\n        ;\n\n    if (t < 0.0) {\n        t = 0.0;\n    } else if (t > 1.0) {\n        t = 1.0;\n    }\n\n    return new XY(\n        start.x + AB.x * t\n        , start.y + AB.y * t\n    );\n}\n\nfunction _getDistanceBetweenPoints(pOne, pTwo) {\n    var dx = pOne.x - pTwo.x\n        , dy = pOne.y - pTwo.y\n        ;\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction _getXYStateFromRGB(red, green, blue, limits) {\n    var r = _gammaCorrection(red)\n        , g = _gammaCorrection(green)\n        , b = _gammaCorrection(blue)\n        , X = r * 0.4360747 + g * 0.3850649 + b * 0.0930804\n        , Y = r * 0.2225045 + g * 0.7168786 + b * 0.0406169\n        , Z = r * 0.0139322 + g * 0.0971045 + b * 0.7141733\n        , cx = X / (X + Y + Z)\n        , cy = Y / (X + Y + Z)\n        , xyPoint\n        ;\n\n    cx = isNaN(cx) ? 0.0 : cx;\n    cy = isNaN(cy) ? 0.0 : cy;\n\n    xyPoint = new XY(cx, cy);\n\n    if (!_isInColorGamut(xyPoint, limits)) {\n        xyPoint = _resolveXYPointForLamp(xyPoint, limits);\n    }\n\n    return [xyPoint.x, xyPoint.y];\n}\n\n/**\n * This function is a rough approximation of the reversal of RGB to xy transform. It is a gross approximation and does\n * get close, but is not exact.\n * @param x\n * @param y\n * @param brightness\n * @returns {Array} RGB values\n * @private\n *\n * This function is a modification of the one found at https://github.com/bjohnso5/hue-hacking/blob/master/src/colors.js#L251\n */\nfunction _getRGBFromXYState(x, y, brightness) {\n    var Y = brightness\n      , X = (Y / y) * x\n      , Z = (Y / y) * (1 - x - y)\n      , rgb =  [\n          X * 1.612 - Y * 0.203 - Z * 0.302,\n          -X * 0.509 + Y * 1.412 + Z * 0.066,\n          X * 0.026 - Y * 0.072 + Z * 0.962\n      ]\n      ;\n\n    // Apply reverse gamma correction.\n    rgb = rgb.map(function (x) {\n        return (x <= 0.0031308) ? (12.92 * x) : ((1.0 + 0.055) * Math.pow(x, (1.0 / 2.4)) - 0.055);\n    });\n\n    // Bring all negative components to zero.\n    rgb = rgb.map(function (x) { return Math.max(0, x); });\n\n    // If one component is greater than 1, weight components by that value.\n    var max = Math.max(rgb[0], rgb[1], rgb[2]);\n    if (max > 1) {\n        rgb = rgb.map(function (x) { return x / max; });\n    }\n\n    rgb = rgb.map(function (x) { return Math.floor(x * 255); });\n\n    return rgb;\n}\n\n/**\n * When a color is outside the limits, find the closest point on each line in the CIE 1931 'triangle'.\n * @param point {XY} The point that is outside the limits\n * @param limits The limits of the bulb (red, green and blue XY points).\n * @returns {XY}\n */\nfunction _resolveXYPointForLamp(point, limits) {\n\n    var pAB = _getClosestPoint(limits.red, limits.green, point)\n        , pAC = _getClosestPoint(limits.blue, limits.red, point)\n        , pBC = _getClosestPoint(limits.green, limits.blue, point)\n        , dAB = _getDistanceBetweenPoints(point, pAB)\n        , dAC = _getDistanceBetweenPoints(point, pAC)\n        , dBC = _getDistanceBetweenPoints(point, pBC)\n        , lowest = dAB\n        , closestPoint = pAB\n        ;\n\n    if (dAC < lowest) {\n        lowest = dAC;\n        closestPoint = pAC;\n    }\n\n    if (dBC < lowest) {\n        closestPoint = pBC;\n    }\n\n    return closestPoint;\n}\n\nfunction _gammaCorrection(value) {\n    var result = value;\n    if (value > 0.04045) {\n        result = Math.pow((value + 0.055) / (1.0 + 0.055), 2.4);\n    } else {\n        result = value / 12.92;\n    }\n    return result;\n}\n\nfunction _getLimits(modelid) {\n    var limits = defaultLimits\n        ;\n\n    if (modelid) {\n        modelid = modelid.toLowerCase();\n\n        if (/^lct/.test(modelid)) {\n            // This is a Hue bulb\n            limits = hueLimits;\n        } else if (/^llc/.test(modelid)) {\n            // This is a Living Color lamp (Bloom, Iris, etc..)\n            limits = livingColorsLimits;\n        } else if (/^lwb/.test(modelid)) {\n            // This is a lux bulb\n            limits = defaultLimits;\n        } else {\n            limits = defaultLimits;\n        }\n    }\n\n    return limits;\n}\n\nmodule.exports = {\n    convertRGBtoXY: function(rgb, modelid) {\n        var limits = _getLimits(modelid);\n        return _getXYStateFromRGB(rgb[0], rgb[1], rgb[2], limits);\n    },\n    convertXYtoRGB: _getRGBFromXYState\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/scene.js":"\"use strict\";\n\nvar utils = require(\"./utils\")\n  , Scene = function () {\n  }\n  ;\n\nmodule.exports.create = function () {\n  var scene\n    , arg\n    ;\n\n  if (arguments.length == 0) {\n    scene = new Scene();\n  } else {\n    arg = arguments[0];\n\n    if (arg instanceof Scene) {\n      scene = arg;\n    } else {\n      scene = new Scene();\n\n      // try to populate the new scene using any values that match scene properties\n      if (arg.name) {\n        scene.withName(arg.name);\n      }\n\n      if (arg.lights) {\n        scene.withLights(arg.lights);\n      }\n\n      if (arg.transitionTime) {\n        scene.withTransitionTime(arg.transitionTime);\n      }\n\n      if (arg.data || arg.appData) {\n        scene.withAppData(arg.data || arg.appData);\n      }\n\n      if (arg.picture) {\n        scene.withPicture(arg.picture);\n      }\n    }\n  }\n  return scene;\n};\n\n\nScene.prototype.withName = function(name) {\n  utils.combine(this, {name: utils.getStringValue(name, 32)});\n  return this;\n};\n\nScene.prototype.withLights = function(lightIds) {\n  var ids;\n\n  if (Array.isArray(lightIds)) {\n    ids = lightIds;\n  } else {\n    ids = Array.prototype.slice.call(arguments);\n  }\n\n  utils.combine(this, {lights: utils.createStringValueArray(ids)});\n  return this;\n};\n\nScene.prototype.withTransitionTime = function(milliseconds) {\n  utils.combine(this, {transitiontime: milliseconds});\n  return this;\n};\n\nScene.prototype.withAppData = function(data) {\n  utils.combine(this, {appdata: {data: data, version: 1}});\n  return this;\n};\n\nScene.prototype.withPicture = function(picture) {\n  utils.combine(this, {picture: picture});\n  return this;\n};\n\nScene.prototype.withRecycle = function(recycle) {\n  utils.combine(this, {\"recycle\": recycle});\n  return this;\n};","/home/travis/build/npmtest/node-npmtest-node-hue-api/node_modules/node-hue-api/hue-api/timer.js":"\"use strict\";\n\nvar deepExtend = require(\"deep-extend\")\n  ;\n\nvar minuteValidator = limitValue(0, 59)\n  , hourValidator = limitValue(0, 23)\n  , secondValidator = limitValue(0, 59)\n  , countValidator = limitValue(0, 99)\n  ;\n\nvar Timer = function() {\n};\n\nmodule.exports.create = function() {\n  return new Timer();\n};\n\nTimer.prototype.time = function(hh, mm, ss) {\n  return this.hour(hh).minute(mm).second(ss);\n};\n\nTimer.prototype.hour = function(hh) {\n  if (hh >= 24) {\n    hh = 0;\n  }\n\n  deepExtend(this, {hh: hourValidator(hh)});\n  return this;\n};\n\nTimer.prototype.minute = function(mm) {\n  deepExtend(this, {mm: minuteValidator(mm)});\n  return this;\n};\n\nTimer.prototype.second = function(ss) {\n  deepExtend(this, {ss: secondValidator(ss)});\n  return this;\n};\n\nTimer.prototype.randomize = function(hh, mm, ss) {\n  return this.randomizeHour(hh).randomizeMinute(mm).randomizeSecond(ss);\n};\n\nTimer.prototype.randomizeHour = function(hh) {\n  deepExtend(this, {random: {hh: hourValidator(hh)}});\n  return this;\n};\n\nTimer.prototype.randomizeMinute = function(mm) {\n  deepExtend(this, {random: {mm: minuteValidator(mm)}});\n  return this;\n};\n\nTimer.prototype.randomizeSecond = function(ss) {\n  deepExtend(this, {random: {ss: secondValidator(ss)}});\n  return this;\n};\n\nTimer.prototype.recurring = function(count) {\n  if (count === null || count === undefined) {\n    deepExtend(this, {recurring: \"forever\"});\n  } else {\n    deepExtend(this, {recurring: countValidator(count)});\n  }\n  return this;\n};\n\n\n\nfunction limitValue(min, max) {\n  return function(val) {\n    if (val < min) {\n      return min;\n    }\n\n    if (val > max) {\n      return max;\n    }\n\n    return val;\n  }\n}"}